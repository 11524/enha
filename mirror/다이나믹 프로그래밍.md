동적 계획법(Dynamic Programming). 줄여서 DP라고 많이 부른다. 특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의
값을 이용하여 효율적으로 값을 구하는<del>왠지 모르게 허세가 넘치는</del> 알고리즘이다.

엄밀히, 동적 계획법은 알고리즘이라기보단 문제해결 패러다임에 가깝다. 동적 계획법은 "어떤 문제를 풀기위해 그 문제를 더 작은 문제의
연장선으로 생각하고, 과거에 구한 해를 활용하는" 방식의 알고리즘을 총칭한다. 동적 계획법을 써야 좋은 효과를 얻을 수 있는 문제들은 주로
Optimal Substructure라고 불리는 구조를 가진 것들이다. 쉽게 이야기하면, 뭘 구하기 위해서 했던 계산을 또하고 또하고
계속해야하는 류의 문제를 풀 때 동적 계획법이 효과를 발휘한다는 것.

동적 계획법을 이해하는 가장 쉬운 예시로 피보나치 수열 구하기가 있다. 물론 굳이 동적 계획법을 쓰지 않고도 훨씬 깔끔하게 구할 수 있지만,
이해를 돕기 위해 여기서는 정통적인 동적 계획법으로 풀어본다.

\--

피보나치 수열은 다음과 같이 '재귀함수'의 형태(Recursive Form)로 표현된다.

f(1) = 1  
f(2) = 1  
f(n) = f(n-1) + f(n-2) when n > 2

이 수학적인 정의는 매우 깔끔하지만, 실제로 컴퓨터가 계산하기엔 매우 부적합한 형태이다. 위 정의를 그대로 C언어로 구현하면 아래와 같다.

int f(int n)  
{  

if(n <= 2)  

return 1;

else  

return f(n-1)+f(n-2);

}

C언어를 열심히 배운 사람들은 다 알겠지만, 함수가 호출되면 프로그램 메모리의 스택(Stack)이라는 곳에 데이터가 쌓이게 된다. 그 함수의
실행이 끝났을 때 다시 메모리가 해제되는 방식인데, 이 말인 즉슨 함수가 계속 호출되면 메모리에 쌓이는 것들이 계속 증가한다는 소리다!
여기서 재귀적 피보나치 함수의 문제가 드러난다. 5번째 피보나치 수열을 구하기 위해선 다음과 같은 함수 호출이 발생한다.

f(5)를 구하기 위해서 f(4)와 f(3)을 구함  
-> f(5)에서 호출된 f(4)를 구하기 위해서 f(3)와 f(2)를 호출함  
-> f(4)에서 호출된 f(3)을 구하기 위해서 f(2)와 f(1)을 호출함  
-> f(5)에서 호출된 f(3)을 구하기 위해서 f(2)와 f(1)을 호출함 (또 호출함)  
-> 총 9번 호출됨

숫자가 작으니 망정이지, 숫자가 조금만 커져도 시간 복잡도와 공간 복잡도가 지수 스케일로 폭발한다! (이런 걸 Exponential
Explosion이라고 한다) 시간 복잡도야 대충 1년 정도 개기면 된다해도, 공간 복잡도의 경우 스택 오버플로우가 발생해 프로그램이
튕겨버린다.

\--

동적 계획법에서는 이런 '삽질(=반복계산)'을 막기 위해 이전에 계산했던 값들을 배열에 저장한다. C언어로 구현하면 아래와 같다. 다만
상황에 따라서 다르게 짤 수도 있기 때문에 절대적인 정답은 아니다.  

    
    
    int f_data[N] = {1, 1}; // N은 정의하기 나름int last_pos = 1; // 마지막으로 계산한 지점int f(int n){    int i;    if(f_data[n-1] == 0)     // 아직 구한 적이 없으면 구한다    {        for(i=last_pos+1; i<n; ++i)        {            f_data[i] = f_data[i-1] + f_data[i-2];        }        last_pos = n-1;    }    return f_data[n-1];}

이렇게 하면 숫자를 저장하는 공간이 계속 필요한 대신 O(n)의 시간 복잡도로 상큼하게(...) 구할 수 있다. 간단한 트릭을 쓰면 공간
복잡도 마저 O(1)로 만들 수 있지만 동적 계획법이랑 관계가 없으니 여기선 생략한다.

\--

적절한 경우에 동적 계획법을 사용하면 막대한 양의 메모리를 희생하는 대신 겁나 빠르게 해를 계산해준다. 지수 복잡도 알고리즘을 다항 시간으로
줄여주기도 하고, 같은 다항 시간 알고리즘도 차수를 낮추는 기적을 보여준다.

그러나 퍼포먼스가 좋은만큼 난해하고 복잡하고 디버깅하기 힘들고.... 다른 알고리즘에 비해서 풀이가 직관적으로 떠오르지 않기 때문에,
초심자들이 [멘탈 붕괴](%EB%A9%98%ED%83%88%20%EB%B6%95%EA%B4%B4.md)를 심하게 겪는다. 간단한 동적
계획법들은 1차원 배열을 사용하는데, 조금만 문제가 복잡해지면 2차원 이상의 배열을 써야 한다!!! 그렇다고 항상 그게 맞느냐 하니, 경우에
따라선 2차원 이상의 배열을 쓴게 1차원보다 더 거지같을 수도 있다.

동적 계획법을 써서 구현할 수 있는 것들은 대개
[백트래킹](%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9.md)으로도 구현할 수 있는데, 백트래킹은 거의 모든
경우를 다 체크하기 때문에 동적 계획법이 빠르다. 하지만 상황에 따라서는 동적 계획법으로는 오버플로우가 날 수도 있지만 백트래킹으로는
돌아가는 경우도 있다.

ACM ICPC 등의 알고리즘 대회에서 동적 계획법을 사용해야 해결할 수 있는 문제가 자주 출제된다. <del>학부생 죽는소리 안나게
해라</del> 대표적인 "아주 기초적인<del>뭐?</del>" 동적 계획법 문제로 아래와 같은 것들이 있다.

\- 3항 이상의 재귀 수열  
\- 배낭 문제(Knapsack Problem) : 견딜 수 있는 무게가 제한된 배낭에 좋은 거 많이 넣기  
\- 가장 긴 증가 수열 문제(LIS Problem) : 아무 수열이나 주고, 순서를 바꾸지 않은 상태로 뽑아서 만들 수 있는 가장 긴
수열의 길이 구하기  
\- 그래프 상의 최단거리 문제

