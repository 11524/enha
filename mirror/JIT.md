## Contents

    

1. Just-in-time 컴파일 
    

1.1. JIT 컴파일을 사용하는 구현의 예

[[edit](http://rigvedawiki.net/r1/wiki.php/JIT?action=edit&section=1)]

## 1. Just-in-time 컴파일 ¶

  

[컴퓨터 과학](%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B3%BC%ED%95%99.md)과 [프로그래밍 언어](/
wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)에서
사용하는 용어. [C](C%28%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%29.md)나 [C++](C++.md)에서 하는 것처럼 프로그램을 실행하기 전에 처음 한 번
[컴파일](%EC%BB%B4%ED%8C%8C%EC%9D%BC.md)`[1]`하는 대신, 프로그램을 실행하는 시점에서 필요한 부분을
즉석에서 [컴파일](%EC%BB%B4%ED%8C%8C%EC%9D%BC.md)하는 방식을 말한다.

  

보통 [인터프리터](%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0.md) 방식의 언어 구현들이 성능
향상을 목적으로 도입하는 경우가 많은데, 같은 코드를 매번 해석하는 대신 실행하기 전에 그 부분만 컴파일을 해 두고 다음부터는 컴파일된
코드를 쓰기 때문에 인터프리터의 느린 실행 성능을 개선할 수 있다. JIT 이전부터 실행 성능 문제 때문에
[바이트코드](%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C.md) 컴파일을 도입했던
[Java](%EC%9E%90%EB%B0%94#s-2.md)와 같은 언어들도 바이트코드를 해석하는 대신 컴파일된
[기계어](%EA%B8%B0%EA%B3%84%EC%96%B4.md) 코드를 직접 실행하는 쪽이 어쨌든 빠르기 때문에 역시 도입하고
있다.

  

단점이라면 초기 구동 후 얼마간은 소스코드(혹은 바이트코드)를 컴파일하는 데에 시간과 메모리를 소모하기 때문에 정적 컴파일된 프로그램에 비해
초기 실행 속도와 메모리 사용량에서 손해를 본다는 것으로, 특히 실행 시간이 매우 짧은 경우에는 애써 컴파일된 코드를 제대로 울궈먹기도 전에
프로그램이 끝나는 배보다 배꼽이 더 큰 상황이 벌어지기도 한다.`[2]`

  

크게 나눠서 [HotSpotVM](%EC%9E%90%EB%B0%94%20%EA%B0%80%EC%83%81%20%EB%A8%B8%EC%8B%A0.md)과 같이
메소드(함수) 단위로 JIT 컴파일을 하는 방식과, 그보다 더 작은 단위에서 프로그램 실행 흐름을 실시간으로 추적하며 컴파일할 코드를
탐색하는 tracing JIT 방식으로 분류할 수 있다. 특히 tracing JIT의 경우에는 **실행 시점에만 알 수 있는 정보를 컴파일에
적극적으로 반영**`[3]`하기 때문에 이론적으로는 정적 컴파일 방식보다 더 빨라질 수도 있다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/JIT?action=edit&section=2)]

### 1.1. JIT 컴파일을 사용하는 구현의 예 ¶

  

  * [Java HotSpot VM](%EC%9E%90%EB%B0%94%20%EA%B0%80%EC%83%81%20%EB%A8%B8%EC%8B%A0.md) ([Java](%EC%9E%90%EB%B0%94#s-2.md), JDK 1.3 이후)
  * .NET CLR ([C#](C%23.md) 등의 [.NET Framework](.NET%20Framework.md) 계열 언어)
  * LuaJIT ([Lua](Lua.md))
  * [PyPy](PyPy.md) ([Python](%ED%8C%8C%EC%9D%B4%EC%8D%AC#s-2.md))
  * [TraceMonkey](%EB%AA%A8%EC%A7%88%EB%9D%BC%20%ED%8C%8C%EC%9D%B4%EC%96%B4%ED%8F%AD%EC%8A%A4.md), [V8](%ED%81%AC%EB%A1%AC%28%EC%9B%B9%20%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%29.md) ([JavaScript](JavaScript.md))
  * Dalvik VM ([Java](%EC%9E%90%EB%B0%94#s-2.md), [안드로이드](%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%28OS%29.md))
  * [플래시](%EC%96%B4%EB%8F%84%EB%B9%84%20%ED%94%8C%EB%9E%98%EC%8B%9C.md) ([액션스크립트](%EC%95%A1%EC%85%98%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8.md) 3.0)

`\----`

  * `[1]` JIT 컴파일에 대비해서 정적 컴파일(static compilation)이라고 부르기도 한다. 
  * `[2]` 보통 그 정도로 실행시간이 짧은 프로그램은 어차피 컴파일해서 돌리나 인터프리터로 돌리나 몇 초 차이나지도 않는 경우라 오히려 스크립트 언어로 짜고 대충 돌리는 경우가 많긴 하지만, **벤치마크를 할 때는 이것 때문에 본의 아니게 평판을 깎아먹곤 한다.** 특히 초심자들이 JIT따위 고려하지 않은 어설픈 벤치마크 코드를 짜놓고 "아 Java 구리네 C만세" 이러는 경우가 간혹 있다. 
  * `[3]` 가능한 최적화의 예로, 루프 내에서 어떤 객체의 메서드를 자주 부른다는 걸 파악하면 컴파일할 때 객체의 메서드를 동적으로 찾는 대신, 해당 메서드의 위치를 정적으로 바인딩해버릴 수 있다. 

