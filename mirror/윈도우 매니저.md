## Contents

    

1 분류

    

1.1 컴포지팅과 스택킹 방식

1.2 타일링 방식

컴퓨터 운영체제에서 윈도우 매니저란 말그대로, GUI 환경에서 각 프로그램들이 뜨는 창을 다루는 프로그램을 뜻한다. MS 윈도우 운영체제나
애플 Mac OS X 같은 운영체제에서는 운영체제 기본시스템에 포함되어있지만, 리눅스 및 BSD 유닉스등은 윈도우 매니저 역시 어플리케이션
취급하기때문에 원하는 윈도우 매니저를 골라서 인스톨하여 사용할 수 있다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%9C%88%EB%8F%84%EC%9A%B0%20%EB%A
7%A4%EB%8B%88%EC%A0%80?action=edit&section=1)]

## 1 분류 ¶

  

크게 컴포지팅, 스택킹, 타일링으로 나뉜다. 컴포지팅과 스택킹은 이미 대다수의 유저들이 사용하고 있는 그 방식이기때문에, 여기서는 타일링
윈도우에 보다 중점을 두어 설명될것이다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%9C%88%EB%8F%84%EC%9A%B0%20%EB%A
7%A4%EB%8B%88%EC%A0%80?action=edit&section=2)]

### 1.1 컴포지팅과 스택킹 방식 ¶

  

컴포지팅 방식은 오늘날 데스크탑 환경에서 가장 많이 사용되는 방식으로, 모든 각각의 창을 메모리에 저장해서 다루기때문에 화면상에서 해당
윈도우가 안보여도 컴퓨터는 그것을 위해 계속 일을 한다. 반면, 스택킹 방식은 정확히 모니터에 표현되는 부분만(다른 윈도우에 겹치지 않은
부분)부분에 대해서만 컴퓨터가 일을 하고, 나머지부분은 신경을 안쓴다. 얼핏 보면 컴포지팅은 스택킹에 비해 매우 비효율적인 시스템같지만, 이
방식의 커다란 이점은 바로 그래픽 효과이다. 특히, 윈도우가 겹쳐서 뒤쪽 윈도우 일부분이 안보일때, 그 뒤쪽의 윈도우가 겹쳤다고 그쪽을
표현하는것을 컴퓨터가 포기해버리면 앞쪽 윈도우에 투명화를 걸어줬을 경우,

  

![transtacking.png](http://z1.enha.kr/http://rigvedawiki.net/r1/wiki.php/%EC%9
C%88%EB%8F%84%EC%9A%B0%20%EB%A7%A4%EB%8B%88%EC%A0%80?action=download&value=tra
nstacking.png)

  

와 같이 투명화를 시켰는데, 뒤의 윈도우는 안보이고 바로 배경화면이 보이는 결과가 발생한다. 따라서, 스택킹 방식에서의 투명화는 Pseudo
transparency 라 칭하며, 컴포지팅에서의 투명화는 Real transparency 혹은 translucency 라 이야기한다.
이외에도 기타 3D 효과들은 컴포지팅 방식으로만 가능한것들이 대부분이다. 물론, 리소스는 스택킹에 비해 그만큼 많이 잡숴드신다. 이 두가지
방식은 일반 데스크탑 사용자들이라면 대부분 친숙할것이다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%9C%88%EB%8F%84%EC%9A%B0%20%EB%A
7%A4%EB%8B%88%EC%A0%80?action=edit&section=3)]

### 1.2 타일링 방식 ¶

  

타일링의 경우는 위 두가지 방식과는 개념적으로 다르게 접근하는데, 보통 유닉스 운영체제에서는 친숙한 가상 데스크탑과 연동하여 쓰는 경우가
많다. 기본적으로, 수많은 창을 한꺼번에 띄워서 쓰는 유저들이 주로 택하는 기능우선주의 방식으로, 프로그램을 실행하여 창을 띄울경우, 절대
겹치지 않도록 창 배열을 알아서 해주는 특징이 있다. 절대 겹치지 않으므로, 스택킹이나 컴포지팅같이 안보이는 부분을 표현할것인가 말것인가와
같은 고민 자체가 필요없으며, 창 1개를 띄울경우 전체화면, 2개를 띄울경우 전체화면을 반으로 갈라 양쪽에 하나씩 꽉차게 띄우는식으로 언제나
전체화면을 다 활용한다. 참고로, 동일하게 비율을 나누지는 않고, 현재 작업하는 창에 보다 큰 화면비율을 배분하는것이 일반적이다.`[1]`
이 방식의 또하나의 특징은 키보드 단축키 위주로 만들어지는 경우가 많다는것인데, 이는 아무래도 일반유저가 대상이 아닌, 좀 마이너한 성향의
고급유저들을 겨냥하여 만들어진 윈도우 매니저이기때문이다.

  

타일링 방식의 또하나의 특징은 태스크 매니저가 필요없다는것이다. 컴포지팅이나 스택킹의 경우는 여러개의 윈도우를 띄울경우, 윈도우가 겹쳐서
안보이는 경우도 많기때문에 이것을 다루기 위해 화면 가장자리 부근에다가 띄워진 모든 창의 이름을 나열하고 선택할 수 있는 태스크 매니저가
필수적이다. 그러나, 타일링 방식은 애초에 겹쳐지질 않는다. 즉, 현재 화면에 보이는 창 전부가 현재 화면에 띄워진 창 전부이기때문에,
태스크매니저 역할을 자동으로 겸하게 되는것이다. 특히 동일한 프로그램을 여러개 띄워놓았을 경우(유닉스 유저들의 경우, 주로 터미널을 여러개
띄워 사용한다. 수개에서 많게는 수십개.), 스택킹/컴포지팅의 태스크 매니저로는 이름이 전부 같으므로, 그중 하나를 골라서 선택하는것이
힘들지만, 타일링 방식에서는 해당 창의 내용물까지 보여주기때문에 창 선택면에서 오히려 더 유리하다.

  

단점은, 언제나 전체화면을 활용하기때문에 작아도 되는 창까지 크게 표현되는 경향이 있다. 예를들어, 메신저라든가 파폭에서 다운로드 창이라든가
Yes or No 를 선택하는 Dialog 창같은 경우는 커져야 할 이유가 없는데도 이런 창이 뜨면 순식간에 전체화면이던 파폭 창이 절반으로
줄어들면서 모니터 반쪽을 저런 창이 차지하게 된다. 또한, 해상도 혹은 화면비율이 중요한 비디오 플레이어의 경우 역시 타일링 윈도우 매니저로
자동배열될 경우, 비디오 플레이어 혹은 미디어파일 자체적인 화면비율이 무시될수밖에 없기때문에 이런경우도 문제가 많다. 물론, 알아서 원상복귀
시키거나 수동으로 배열하면 되지만 매번 이러는것도 꽤 짜증나는 일이다.

  

덕분에 요즘 타일링 윈도우 매니저는 Stacking 방식을 대부분 겸하고 있으며, 설정에서 스택킹 방식으로 띄울 프로그램을 선택할 수 있게끔
한다.(물론, 타일링 방식의 설정은 대부분 수동으로 파일을 고치는식이고, 몇몇 타일링 윈도우 매니저는 아예 프로그램 자체를 고쳐서
재컴파일하는 방식을 이용한다.(xmoand, dwm 등)) 이렇게 타일링과 스택킹이 결합된 방식을 다이나믹 방식이라 하기도 한다.

  

아무래도 3D 효과도 불가능하고, 언제나 전체화면을 활용하기때문에 배경화면의 역할도 거의 없어 눈즐거움에서는 최악에 가깝지만, 가상
데스크탑과 겸할경우 헤비유저들에게 기능면에서는 압도적인 최강을 자랑한다. 각 창을 파일이라 하면, 가상 데스크탑은 폴더라 볼 수 있다. 즉,
파일이 1-2 개 있을때는 폴더같은게 필요가 없지만, 수십개의 이상의 파일을 관리할 경우, 폴더로 알기쉽게 분류해서 사용한다면 파일을 찾기가
훨씬 편하다는것은 다들 알고 있을것이다. 가상 데스크탑도 이런 개념으로, 가상 데스크탑을 적극적으로 사용하는 유저들은 본인의 용도에 따라
수학, 과학, 국어등등으로 분류하던가 개발, 멀티미디어, 잡동사니등으로 분류하던가 하는식으로 대부분 자신만의 창 분류법을 갖고있으며, 그
방식에 따라 창을 각각의 가상 데스크탑에 분류하여 집어넣고 사용한다. 이럴경우, 동일한 xterm 이 수십개 띄워져 있어도 게중에 하나를
찾고싶을때 일단 가상데스크탑을 통한 1차분류로 그것이 해당되는 가상데스크탑을 찾고, 해당 가상데스크탑 화면으로 들어가면 스택킹/컴포지팅
방식의 태스크매니저처럼 프로그램 이름 혹은 썸네일정도만 달랑 뜨는게 아닌, 내용물까지 보여주는 타일링 윈도우는 원하는 창을 손쉽게 찾을 수
있게 만들어준다. 무엇보다 대다수의 타일링 윈도우 매니저에서는 이 모든것이 마우스를 통하지 않고 오로지 키보드로만 가능하다는 커다란 장점이
있다.

  

일반적으로 타일링 윈도우 매니저를 사용하는 이들은 일반 유저들이 상상하는것 이상으로 수많은 프로그램을 동시에 사용하는 경향이 있기때문에
대부분 가벼운 프로그램 위주로 사용하며, 타일링 윈도우 매니저 자체도 그것을 감안하여 극도로 가볍게 만들어지는 경우가 많다.`[2]` dwm
의 경우 C 로 만들어졌으며, 코드의 라인 수가 2000 줄을 넘지 않는것으로 유명하다. xmonad 는 하스켈로 만들어져 리소스는 dwm
보다 조금 더 먹지만, 전체 코드는 1200 줄정도이며, 수많은 기능확장이 가능하다. 물론, 그 기능확장은 하스켈 코드를 직접 수정하여
재컴파일하는식으로 진행된다는게 문제이긴 하지만.(dwm 역시 헤더파일을 수정하여 재컴파일하는식의 세팅방식을 이용한다.)

`\----`

  * `[1]` 창 1-2 개라면 문제가 없지만, 10개 이상의 창을 띄울경우(타일링 윈도우 매니저를 사용하는 이들에겐 드문일이 아니다.), 비율을 동일하게 배분한다면 모든 창이 전부 작업이 불가능할정도로 작아지기때문에 실용성이 전혀 없다. 
  * `[2]` 사실 컴포지팅 방식의 윈도우 매니저를 사용하는 대다수의 유저들은 컴포지팅 윈도우 매니저 자체도 무겁고, 사용하는 어플리케이션 자체도 뽀샤시한 그래픽으로 리소스를 많이 먹는것들을 많이 쓰기때문에 한꺼번에 여러 프로그램을 돌리게 되면 그 창을 찾는게 문제가 아니라, 컴퓨터가 버티는가 뻗어버리는가의 문제가 우선한다. 덕분에 이들에게는 한꺼번에 수십개의 프로그램을 띄워본 경험 자체가 없거나 가능해도 위험한것이라는 인식을 갖고있는 경우가 대부분이라, 컴포지팅/태스크매니저 방식에서 창을 여러개 띄우면 찾기가 불편한지도 모르는 경우가 많다. 

