Buffer Overflow

## Contents

    

1. 개요 
2. 왜 문제가 되는가 
3. 대처법 

[[edit](http://rigvedawiki.net/r1/wiki.php/%EB%B2%84%ED%8D%BC%20%EC%98%A4%EB%B
2%84%ED%94%8C%EB%A1%9C%EC%9A%B0?action=edit&section=1)]

## 1. 개요 ¶

[버그](%EB%B2%84%EA%B7%B8.md)의 일종. 또는 이를 이용한 공격 방법.

  

[프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)이 실행 될 때 입력받는 값이
[버퍼](%EB%B2%84%ED%8D%BC.md)를 가득 채우다 못해 넘쳐흘러 버퍼 이후의 공간을 침범하는 현상.  
쉽게말해 양동이(버퍼)에 물(값)을 받을 때(입력받기) 물을 너무 많이 받아 바닥에 흘러 넘쳐 버리는 것이라고 생각하면 된다.

  

주로 [프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)이 사용자에게 데이터(주로
[문자열](%EB%AC%B8%EC%9E%90%EC%97%B4.md))을 입력받을때 사용자가 말을 곧이곧대로 듣지 않고 이미 준비된
버퍼보다 더 많은 양의 데이터를 입력할 때 발생하나, [해커](%ED%95%B4%EC%BB%A4.md)가 임의로
[프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)의
[메모리](%EB%A9%94%EB%AA%A8%EB%A6%AC.md)의 값을 (주로
[스택](%EC%8A%A4%ED%83%9D.md))) 변조할 때에도 쓰인다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EB%B2%84%ED%8D%BC%20%EC%98%A4%EB%B
2%84%ED%94%8C%EB%A1%9C%EC%9A%B0?action=edit&section=2)]

## 2. 왜 문제가 되는가 ¶

버퍼 오버플로우가 발생 시 [버퍼](%EB%B2%84%ED%8D%BC.md)에 다 담지 못한 값들은
[버퍼](%EB%B2%84%ED%8D%BC.md) 이후의 공간에 들어차게 된다.  
문제는 이 들어차는 방식이 밀어내기가 아닌 **덮어쓰기** 라는 것.

  

가령 8칸짜리 [메모리](%EB%A9%94%EB%AA%A8%EB%A6%AC.md)가 있고, 그 안에 4칸짜리
[버퍼](%EB%B2%84%ED%8D%BC.md)가 있을 때,

  

![buffer_overflow.png](//rv.wkcdn.net/http://rigvedawiki.net/r1/pds/buffer_ove
rflow.png)

[PNG image (29.12 KB)]

  

이와 같이 사용자가 [버퍼](%EB%B2%84%ED%8D%BC.md)를 초과하는 값을 입력하면
[버퍼](%EB%B2%84%ED%8D%BC.md) 이후의 값이 바뀌게 된다.

  

문제는 이걸 프로그램은 **전혀 모르고 있는 상태**라는 것.`[1]` 심지어 버퍼 이후의 값이 바뀌어도 프로그램은 이를 전혀 사용자에게
통지하지 않는다!!

  

중요하지 않은 10줄~50줄짜리 소규모 예제 [프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)이라면
이는 딱히 신경쓰지 않아도 되지만, 중형이나 대규모 프로젝트라면 이야기가 달라진다. 이 원리를 통해
[해킹](%ED%95%B4%ED%82%B9.md)이 가능하기 때문.

  

만약 버퍼를 초과하여 쓰여지는 값이 [프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)의
RET`[2]`값을 덮어쓰게 된다면, 사용자가 프로그램의 진행 상황을 통제할 수 있게 된다. 만약 특정한
[함수](%ED%95%A8%EC%88%98.md)가 있고, 이 [함수](%ED%95%A8%EC%88%98.md)의 주솟값을 알고
어떤 입력이 버퍼 오버플로우 공격이 가능하다면, 그냥 '입력받는 문자열 + 4바이트(SFP 덮어쓰기용) + 해당 함수 주소'를 입력값에
쑤셔넣어 입력 함수가 끝나면 자신이 원하는 함수로 점프할 수가 있게 된다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EB%B2%84%ED%8D%BC%20%EC%98%A4%EB%B
2%84%ED%94%8C%EB%A1%9C%EC%9A%B0?action=edit&section=3)]

## 3. 대처법 ¶

요즘은 컴파일러 레벨에서 이 오버플로우에 대한 처리를 다 해준다. [Visual Studio](Visual%20Studio.md)같은
경우에는 컴파일러가 버퍼 생성시 앞뒤로 2바이트짜리 영역을 만들어 [디버깅](%EB%94%94%EB%B2%84%EA%B9%85.md)시
이 위치의 값이 바뀌면 버퍼 오버플로우가 발생한 것으로 판단하고 [예외](%EC%98%88%EC%99%B8.md)를 때려 버리며, 아예
버퍼 오버플로우가 발생하기 쉬운 함수(strcpy 등)은 이를 방어 가능한 함수(strcpy_s 등)으로 교체하라고 경고`[3]`를 해
준다. 물론 이렇게 다 해준다고 마냥 안심하고 있긴 어려운 것이, 버퍼 오버플로우는
[프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)이 Input을 받는 모든 곳에서 발생할 수
있으므로 [프로그래머](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8.md)도 값을 입력받을 때
갖가지 예외 처리를 통해`[4]` 이 값이 과연 올바른 값인지 꼼꼼히 따져봐야 한다.

`\----`

  * `[1]` 물론 이는 과거 로우 레벨까지 [프로그래머](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8.md)가 [세세하게 코딩해야 됬었던 때](C%EC%96%B8%EC%96%B4.md)의 이야기고, 요즘은 디버깅시 컴파일러가 버퍼 앞뒤에 오버플로우 방어용 1~4바이트짜리 값을 넣어 침범되었을 경우 예외를 때려버리거나 코딩 단계에서 '이 함수는 버퍼 오버플로우의 위험이 있음' 이라고 경고를 해준다. 물론 이 현상이 사라진건 아니므로 [프로그래머](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8.md)는 여전히 버퍼에 들어가는 값을 체크 해야 된다.
  * `[2]` 현재 함수의 실행이 끝나면 호출 스택을 타고 상위 함수로 올라가는데, 이때 쓰이는 값
  * `[3]` VS 2013부터 경고(warning)에서 에러(error)로 변경. 설정을 통해 다시 경고 수준으로 격하시킬 수는 있다.
  * `[4]` 가령 main함수의 argv 문자열 값으로 넘어오는 값이 버퍼를 초과할 수 있으므로 int형 변수를 먼저 선언하고 다른 변수를 선언해 argv-int-다른 변수 순으로 쌓이는 스택의 특성을 이용하여 int형 변수의 값이 바뀌면 이를 버퍼 오버플로우라 판단해 차단해버리는 [스택 가드](%EC%8A%A4%ED%83%9D%20%EA%B0%80%EB%93%9C.md) 기법이 있다.

