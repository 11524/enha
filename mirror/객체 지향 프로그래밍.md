  * 관련 항목 : [컴퓨터 관련 정보](%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4.md) \- [프로그래밍](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md)

## Contents

    

1. 개요 
2. 역사 
    

2.1. 시작과 발전

2.2. 지원하는 언어

3. 설명 
    

3.1. 캡슐화(Encapsulation)

3.2. 상속(Inheritance)

3.3. 다형성(Polymorphism)

4. [원칙](%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99.md)
5. 장단점 
6. 기타 
    

6.1. 교육의 어려움

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=1)]

## 1. 개요 ¶

객체 지향 프로그래밍(Object-Oriented Programming), 줄여서 [OOP](OOP.md). <del>배우는 사람을
**OOP**s! 소리 나오게 만드는 개념</del>

  

[프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)을 어떻게 설계해야 하는지에 대한 일종의 개념이자
방법론.

  

프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는
방식이다.

  

프로그래밍에 관심이 없는 사람들을 위해 쉽게 설명하자면, 객체 지향 프로그래밍은 캐릭터 중심의 소설 쓰기로 비유할 수 있다. 즉 절차 지향
프로그래밍이 '시나리오를 구상하고, 그것에 맞는 캐릭터를 창조한다'는 전통적 의미의 소설쓰기에 해당한다면, 객체 지향 프로그래밍은 '캐릭터를
창조하고, 그 캐릭터에 맞는 시나리오를 구상한다'는 라이트 노벨식 소설쓰기에 해당한다고 볼 수 있다. 물론 이는 일반인을 위한 설명이고,
당신이 컴퓨터과학을 공부하고자 한다면 이정도로 이해해서는 안된다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=2)]

## 2. 역사 ¶

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=3)]

### 2.1. 시작과 발전 ¶

초기 프로그래밍 방식은 **[절차적 프로그래밍](%EC%A0%88%EC%B0%A8%EC%A0%81%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md)** 방식이었다.
[학교대사전](%ED%95%99%EA%B5%90%EB%8C%80%EC%82%AC%EC%A0%84.md)의 [고등학생
알고리즘](http://dic.idoo.net/s/dic/pics/student.gif)처럼 입력을 받아 명시된 순서대로 처리한 다음, 그
결과를 내는 것뿐이라는 생각이 지배적이었다. 프로그램을 명령어의 모음으로 인식한 것이다. 또한 프로그래밍이란 어떻게 어떤
[논리](%EB%85%BC%EB%A6%AC.md)를 어떤 순서대로 써나가는 것인가로 간주되었다. 즉, 프로그램 자체가 가지는 기능에
대해서만 신경을 썼지, 이 프로그램이 대체 어떤 데이터를 취급하는 것인가에는 그다지 관심이 없었던 것이다.

  

문제는 이 방식은 간단한 [알고리즘](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md)이면 모를까 조금만
복잡해져도 순서도로 나타내는 것이 불가능할 정도로 꼬인
"[스파게티](%EC%8A%A4%ED%8C%8C%EA%B2%8C%ED%8B%B0.md) 코드"가 나오게 된다. 간단히 말해서
[스타크래프트](%EC%8A%A4%ED%83%80%ED%81%AC%EB%9E%98%ED%94%84%ED%8A%B8.md)를 위의
순서도로 그려야 된다고 생각해봐라! 이렇게 꼬인 코드를 다른 사람이 보고 이해하는 것은 거의 불가능하고 심지어는 작성한 본인조차도 유지보수에
어려움을 겪게 된다.

  

이 문제를 해결하기위해 [에츠허르 다익스트라](%EC%97%90%EC%B8%A0%ED%97%88%EB%A5%B4%20%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC.md)가 1968년 "[GOTO](GOTO.md)문의 해로움"(Go
To Statement Considered Harmful)이라는 논문에서 프로그램을
[함수](%ED%95%A8%EC%88%98.md)(프로시져) 단위로 나누고 프로시져끼리 호출을 하는 **[구조적 프로그래밍](/wiki
/%EA%B5%AC%EC%A1%B0%EC%A0%81%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)*
* 방식을 제안하면서 이러한 위기를 벗어나게 된다. 프로그램이라는 큰 문제를 해결하기 위해 그것을 몇개의 작은 문제들로 나누어 해결하기
때문에 하향식(Top-down) 방식이라고도 한다.

  

하지만 이런 하향식 방식에도 문제가 있는데, 문제를 작게 나눠서 해결하는 방식은 원래 문제가 바뀔 경우 나누는 방법도 바뀌게 된다. 즉,
기존의 코드를 재사용하기가 어려워서 매번 현실의 문제에 맞게 다시 코딩해야 한다. 이러다보니
[소프트웨어](%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4.md)를 개발하는데 드는 시간과 비용은
늘어만 갔다. [하드웨어](%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4.md)의 발전속도는 [무어의법칙](%EB%AC%B4%EC%96%B4%EC%9D%98%20%EB%B2%95%EC%B9%99.md)에 맞춰 급격하게 증가하는 반면에
소프트웨어의 발전 속도는 하드웨어를 따라잡을 수 없었다. 이런 현상을 소프트웨어 위기(Software Crisis)라고 한다.

  

이를 극복하기 위한 대안으로 등장한 것이 바로 객체 지향 프로그래밍이다. 큰 문제를 작게 쪼개는 것이 아니라, 먼저 작은 문제들을 해결할 수
있는 객체들을 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하는 상향식(Bottom-up) 해결법을 도입한 것이다. 이 객체란 것을 일단
한번 독립성/신뢰성이 높게 만들어 놓기만 하면 그 이후엔 그 객체를 수정 없이 재사용할 수 있으므로 개발 기간과 비용이 대폭 줄어들게 된다.

  

객체 지향 프로그래밍은 등장 당시에는 기존의 절차형 프로그래밍과 매우 이질적이고, 당시 컴퓨터의 처리능력이 별로 좋지 않아서 별 주목을 받지
못하다가, [GUI](GUI.md)가 등장하면서 급부상하게 된다. 화면에 떠 있는 창 속에서 프로그램의 명령에 따라 출력을 하면서
동시에 마우스 클릭이나 키보드 입력, 프로그램 내부 상태 변화에 따른 반응도 처리해야 하며, 이러한 것들이 이전처럼 순서대로 수행되는 것이
아닌, 특정한 이벤트가 발생하면 실행되게 되어 프로그램을 구현하는 데 많은 어려움이 발생했다. 그래서 OOP를 도입하여 이벤트를 받았을 때
수행되는 기능(Event Handler, Callback)을 구현할 수 있는 단일 인터페이스를 정의하고, 프로그래머들은 이를 필요한 형태로
알아서 구현하며, 특정 이벤트가 일어났을 때 실행되어야 하는 기능들을 등록한 다음, 운영체제나 응용프로그램이 실제로 해당 이벤트가 발생했을
때 해당 이벤트에 등록된 이벤트 핸들러/콜백을 주욱 실행하기만 하면 되는 구조가 본격적으로 확산되면서 OOP또한 빠르게 확산되었다.

  

이러한 OOP의 인터페이스를 사용한 추상화와 이벤트 기반(Event-Driven) 방식은 네트워크 프로그래밍, 특히 요청-응답 으로 동작하는
HTTP 서버에도 매우 적합했으며, 때마침 시기 적절하게 등장한 본격 OOP 언어인 [Java](Java.md)가 서버 쪽에서 널리
사용되게 되는 원인이 되었다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=4)]

### 2.2. 지원하는 언어 ¶

앨런 케이가 1972년 팔로 알토 리서치 센터([PARC](PARC.md))에서 만든
[Smalltalk](Smalltalk.md)가 최초로 OOP를 지원한 프로그램이다. 시뮬레이션 [프로그래밍언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md)인
[시뮬라-67](http://en.wikipedia.org/wiki/Simula)에서 영향을 받았다.

  

스몰토크는 앨런 케이가 "누구나 쉽게 사용할 수 있는 컴퓨터"를 만들려고 했던 목적에 따라 만들어졌다. 문제는 앨런 케이가 글을 읽고 쓸
수만 있으면 4-5세의 아이들도 프로그래밍 할 수 있는 것을 이상적인 목표로 했기 때문에 프로그래밍을 하고자 하는 목표를 수학적
논리구조([알고리즘](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md))로 개념화한 뒤에 그에 따라 프로그래밍
하는 게 아니고`[1]` 비 수학적인 사고로 문제를 해결도록 언어가 설계되어 있었고, 이 때문에 모든 것을 객체 단위로 분해하고 그 객체들이
메세지를 전달하여 문제를 해결하도록 프로그램을 해야만 한다.

  

브레스 콕스와 톰 러브는 스몰토크를 보고 새로운 시각으로 객체지향을 바라보았는데 그것은 **[소스코드](%EC%86%8C%EC%8A%A4%20%EC%BD%94%EB%93%9C.md)의 수정없는 재활용**이었다. 그들은 이 개념을
실제 언어에 적용하여 1983년도에 스몰토크의 객체 처리 방식을 [C언어](C%EC%96%B8%EC%96%B4.md)에 추가`[2]`한
[Objective-C](Objective-C.md)를 만들어 발표했고 실제 유용하다는 것을 실증하였다. 그리고, Objective-
C는 1989년 당시 가장 혁신적인 [운영체제](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.md)였던
[NeXTSTEP](NeXTSTEP.md)을 개발할때 사용되었다.`[3]`

  

1983년에는 비얀 스트로스트룹이 C언어를 확장시킨 [C++](C++.md)를 발표했다. 이 두 언어의 성공으로 이후
[Java](Java.md), [C#](C.md), [Objective-Pascal](%ED%8C%8C%EC%8A%A4%EC%B9%BC%28%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%29.md)등 많은 객체 지향 언어들이 순수한 객체 지향보다는 기존의 프로그램 언어에 객체 지향 요소를 확장하거나 추가한 형태로 만들어 지게
되었다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=5)]

## 3. 설명 ¶

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=6)]

### 3.1. 캡슐화(Encapsulation)`[4]` ¶

객체 지향 방식의 기본중의 기본 개념이다. 이 캡슐화를 안지키면 나머지 상속과 다형성은 성립이 안된다. 캡술화의 목적은 "코드의 수정 없는
재활용"을 생각해보면 당연한 개념이다. 프로그램 코드를 재활용 하려고 하는데 기능(함수/프로시저 : 메소드)이 분산되어 있고 특성(변수 :
데이터)이 분산 되어 있는 프로그램 코드는 재활용을 하기 매우 힘들다. 이 때문에 관련 기능과 특성을 한곳으로 모으고 분류할 필요성이 있다.

  

객체 지향에서는 이렇게 계층적으로 분류한 기능과 특성의 모음을 클래스(Class)라는 캡슐(capsule)에 분류된 집단 별로 각각 집어
넣는다. 이러한 클래스를 실체화(Instance) 하면 객체(Object)를 만들수 있는데 이것을 쉽게 설명하면 "한국인"이라는 집단에
"홍길동"이라는 한국인을 소속 시킨다(만든다) 라고 할수 있다.

  

실제 컴퓨터에서 물리적으로 일어 나는 현상은 "홍길동" 이라는 객체의 생성을 위해 "한국인 Class"에 정의된 데이터가 들어갈
[메모리](%EB%A9%94%EB%AA%A8%EB%A6%AC.md)를 [힙](%ED%9E%99.md)에 할당 하고 기본적인 한국인
클래스의 특성을 초기화 하기 위해 생성자를 호출 하여 "홍길동" 객체를 초기화 하고 객체를 메모리에 제거할 땐 할당된 자원(메모리,파일
등)을 정리하기 위해 소멸자(Destructor)를 호출한다. 소멸자의 경우에는 [Java](Java.md)나
[.Net](.Net.md)같이 [가비지콜렉터](%EC%93%B0%EB%A0%88%EA%B8%B0%20%EC%88%98%EC%A7%91.md)가 있는 객체 지향 플랫폼일
경우에는 내부적으로 사용하므로 특별한 경우 외에는 소멸자를 프로그램 코드에 넣치 않는다.  

이와 같이 캡슐화는 클래스, 타입, 인스턴스, 생성자, 소멸자 같은 객체 지향 프로그램 방식의 기초를 형성한다. 다음에 설명할 상속성과
다양성은 객체의 메카니즘(작동 원리)이기 때문에 캡슐화를 정확히 표현하지 못하면 상속성과 다형성 또한 표현을 잘못하게 되어 있다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=7)]

### 3.2. 상속(Inheritance) ¶

사실 클래스 이전의 프로그래밍 기법에선 코드 재활용이 불가능하지는 않았다. 예전에도
[라이브러리](%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.md) 등을 통해서 남이 짜놓은 코드를
그대로 가져올 수 있었다.`[5]`

  

라이브러리는 코드의 재활용에 지대한 영향을 미쳤지만 치명적인 단점이 있었다. 라이브러리의 기능을 약간 바꾸어야 할 경우 라이브러리의 소스를
변경해야 했고 이 때문에 전혀 다른 라이브러리가 되어 버린다는 것이다. 이것은 라이브러리 버전에 따라 그 라이브러리를 사용하는 프로그램이
동작을 안할수도 있다는 것이고 불필요한 코드의 수정작업을 해야 한다는 것이다.

  

객체 지향 프로그램에서는 이 문제를 해결하기 위해 "[상속](%EC%83%81%EC%86%8D.md)"을 도입 했다."포용성"으로
이전의 라이브러리보다 더 논리적이고 체계적으로 기능과 데이터를 계층적으로 분류해서 사용의 편의성을 도모하면서, 상속을 사용해 부모 클래스의
특성과 기능을 그대로 이어받고 기능의 일부분을 변경해야 할 경우 상속 받은 자식 클래스에서 그 기능만을 다시 정의하여 수정하게 하였다.
이러한 작업을 "덮어쓰기(재정의 : Override)"라고 한다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=8)]

### 3.3. 다형성(Polymorphism) ¶

하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것을 말한다. 위에서 설명한 오버라이딩 이외에, 변수에 따라 함수의
기능이 달라지는 오버로딩도 여기에 해당한다.

  

C++, C# 등에서는 기본 연산자를 오버로딩해서 기본 연산자가 해당 클래스에 맞는 역할을 수행하게 하는 것도 가능하다. JAVA 등에서는
연산자의 오버로딩이 불가능하다. 펄 6나 스몰토크, F# 등, 연산자의 신규 정의가 가능한 언어도 있다.  
[한글 위키백과의 연산자 오버로딩에 대한 프로그래밍 언어 분류](http://ko.wikipedia.org/wiki/%EC%97%B0%EC%
82%B0%EC%9E%90_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9#.EB.AA.A9.EB.A1.9D)

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=9)]

## 4. [원칙](%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99.md) ¶

[객체 지향 프로그래밍/원칙](%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99.md) 항목 참조.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=10)]

## 5. 장단점 ¶

하여튼, 이러한 특징은 여차저차한 결과로 다음과 같은 장단점을 지니게 된다.

  

  * 데이터 클래스 개념은 [상속](%EC%83%81%EC%86%8D.md)이라는 굉장히 뛰어나지만 마찬가지로 굉장히 개 같은 특성을 지니게 해준다. 이 OOP 특성 덕분에 면밀한 자료 분석`[6]`, 개발시간 단축`[7]`, 좀더 정확한 코딩`[8]`을 보증하지만 **어려워!** 특히, 다중 상속이 되면 엄청 복잡해진다. 그래서 현재에는 다중 상속을 지원하지 않는 OOP 언어가 대부분이며, 다중 상속이 되는 C++ 같은 것도 다중 상속은 최대한 자제하라고 권장하고 있다. 다중 상속의 가장 큰 문제는 순환 상속의 문제 때문이다. 2개의 부모를 가진 자식 클래스의 조상이 겹치는 경우가 발생할수 있는데`[9]`이것을 C++같은 객체 지향 언어는 처리할수 없다.자식이 부모의 조상이 되어 버릴수가 있기 때문이다. 이 때문에 상속을 포기하고 필요한 부모의 기능을 다시 모두 구현해줘야 한다. 이렇게 되면 객체 지향 프로그램 방식으로 프로그램했다고 말하기가 민망해 진다.  

  * 클래스는 오로지 관련 데이터만을 정의하기때문에, 한 클래스의 인스턴트가 수행될 때 다른 프로그램의 데이터를 절대로 건드릴 수 없게 된다. 덕분에 높은 시스템 보안을 제공하고, 자료 훼손을 방지하는 효과가 있다.`[10]`, Visual Studio 6.0의 C++는 데이터베이스의 자료 처리는 변수를 모두 public으로 처리 했었다.이 이유는 데이터베이스의 필드가 50개이면 get과 set 메소드를 모두 구현해주면 100개의 메소드를 구현해줘야 한다.변수 50개와 메소드 100개다 150개를 키보드로 쳐야 한다.생각만 해도 일할 기분이 안난다. 이건 Java도 마찬가지다. 변수의 get과 set메소드 구현은 어째던 굉장히 귀찮은 작업이다. 데이터의 은닉도 중요하지만 프로그래머의 손가락 건강도 생각해 봐야 한다. C#은 2.0부터 프로퍼티 하나만 선언해 주면 되기 때문에 상관 없다.   

  * 클래스의 정의는 최초로 생성한 프로그램뿐 아니라 다른 OOP에서도 똑같이 사용될 수 있다. 그리고, 이런 이유로 네트워크에 쉽게 분산 사용이 가능하지만 프로그래머에게는 아주 힘든 노력을 강요한다. 네트웍 통신이라는 것은 호환성을 위해 7bit ASCII코드로 전송한다. 1960년대 만들어진 통신기기를 사용하는 곳도 아직 있기 떄문이다. 이 때문에 Quarter-Print, Base64나 UTF-8같은 것이 만들어진 것이다. 결국 객체도 7bit ASCII코드로 전송을 해야 한다. 메모리상의 객체 정보를 ASCII 코드 화 하는 것을 직열화(Serialization)라고 하고 ASCII코드를 다시 객체화 하는 것을 역직열화(Deserialization)라고 한다. 하지만 마법처럼 그냥 되는 게 아니고 "직열화 인터페이스"를 프로그래머가 고생해서 구현해 줘서 "직열화 인터페이스"가 있는 객체만 가능 하다. 현실 세계에서는 마법은 없다. 마법처럼 보이는 것이 있을 뿐이다. `[11]`  

  * 데이터 클래스 개념은 언어에 정의되지 않은 새로운 데이터 형식을 프로그래머가 임의로 정할수 있도록 해준다.  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=11)]

## 6. 기타 ¶

참고로, 최근 주목을 받고있는 함수형 패러다임과는 다소 상반된 위치에 있다. OOP 의 경우, 프로그램 유지보수시 데이터 추가는 새로운
클래스를 더하는 것으로 비교적 간단하게 가능하지만, operation set 을 변경할 때는 관련된 다수 클래스를 수정해야 하므로 난잡해지는
경향이 있다. 반대로, 함수형 패러다임에서는 operation set 의 추가는 간단하지만, 데이터 추가는 관련된 다수의 함수를 바꿔야
하므로 난해한 점이 있다. 주의할 점은 OOP 와 함수형 패러다임이 상반된 위치에 있긴 하지만, 대비되는 개념은 아니며, 요즘에는 함수형
언어에도 OOP 개념을 추가한다던가(F#), 반대로 객체지향 언어에 함수형 패러다임을 추가하는(C#, C++, Python 등...)등
멀티패러다임 추세로 가고있다.

  

클래스가 있어야만 객체 지향 프로그래밍 언어라고 생각할 수도 있지만, 사실 클래스 없는 OOP 언어도 꽤 있다. 프로토타입을 이용하는
[JavaScript](JavaScript.md),
[액션스크립트](%EC%95%A1%EC%85%98%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8.md) 2.0, 타입
클래스라는 개념을 쓰는 [Haskell](Haskell.md), 그냥 함수만 써서 다 해먹는(...)
[LISP](LISP.md)등의 각종 함수형 언어 등등...

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%9
6%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?action=edit&section=12)]

### 6.1. 교육의 어려움 ¶

프로그래밍을 배울 때 만나게 되는 난관이기도 하다. [C](C.md)를 배운 뒤 [C++](C++.md)을 배우는 상황에서 특히
심하긴 한데, 곧바로 [Java](Java.md)나 [파이썬](%ED%8C%8C%EC%9D%B4%EC%8D%AC.md)으로 배우기
시작하는 경우에도 마찬가지이다. 왜냐하면 이전까지 배웠던 것은 프로그래밍 언어의
[문법](%EB%AC%B8%EB%B2%95.md)이었다면, OOP는 가장 문제가 덜 생기는 방향으로 코딩하게끔 하는
[가이드라인](%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8.md)이기 때문이다. 이제 막
[알파벳](%EC%95%8C%ED%8C%8C%EB%B2%B3.md)과 기초 영문법을 뗀 학생에게
[수사법](%EC%88%98%EC%82%AC%EB%B2%95.md) 내지는 논리적
[작문](%EC%9E%91%EB%AC%B8.md)을 가르치는 것과 동일한 것이다.

  

이 문제라는 것도 수천, 수만줄짜리 코드를 수년간 유지보수할 때나 몸에 와닿을 텐데, 기껏해야 과제 제출하고 다시 손대지 않을 길어야
수백줄짜리 코드나 짜봤을 학생들에게는 전혀 체감할 수 없다. 게다가 대부분의 언어들은 기존의 언어에 객체지향을 얹어놓은 형태기 때문에 굳이
OOP에 맞춰서 짜지 않아도 원하는 결과는 일단 나온다. 이러한 이유들로 인해 학생들에게 C++ 과제를 내주면 C++ 문법을 사용한 C
프로그램인 경우가 태반이다.

`\----`

  * `[1]` "1+2" 라는 수식도 수식으로 보지 않는다. "1"이라는 객체에 "+2"라는 메세지를 보내는것으로 본다. 쉽게 말하면 "사과1개"에 "사과2개"를 더하는 유치원생의 사고 방식를 생각해 보면 된다. 그래서, (1+2)X2 같은 연산자의 우선순위의 개념은 당연히 없다. 유치원생은 [사칙연산](%EC%82%AC%EC%B9%99%EC%97%B0%EC%82%B0.md)을 이해 못하니까!
  * `[2]` C언어의 표준을 지키면서 스몰토크 방식의 객체 처리 기능을 추가했다. 이렇게 표준 언어에 기능을 추가하는 것을 슈퍼셋(Suppeset)이리고 한다. 반대로 표준언어의 기능을 축소한 것을 서브셋(Subset)이라고 한다. 컴파일러 개발 방법을 교육할 목적으로 만든 [Small-C](http://en.wikipedia.org/wiki/Small-C)가 대표적인 서브셋이다.
  * `[3]` NeXTSTEP은 1996년도에 [Apple](%EC%95%A0%ED%94%8C%28%EA%B8%B0%EC%97%85%29.md)에 인수되어 2001년도에 출시된 [Mac OS X](Mac%20OS%20X.md)의 기반이 되었다.
  * `[4]` '포용성'라고도 불린다 [카더라](%EC%B9%B4%EB%8D%94%EB%9D%BC.md).
  * `[5]` 라이브러리는 실행될 때만 메모리에 로드하면 되기 때문에 메모리를 아끼는 효과도 있었다.
  * `[6]` 단, 초기 개발 요구사항 분석단계에서 글러먹으면 [망했어요](%EB%A7%9D%ED%96%88%EC%96%B4%EC%9A%94.md)
  * `[7]` 잘만들어진 클래스는 재사용성을 보장한다. Ctrl C+V신공보다 클래스 재사용이 낫다.
  * `[8]` 구현 목적을 위해 클래스를 나눌 수 있으니 구현 단위와 목표가 뚜렷해진다.
  * `[9]` 조부나, 증조부나, 고조부중 누군인가가 겹친다고 생각 해봐라
  * `[10]` 하지만 public을 남발해 버리면... [더 이상의 자세한 설명은 생략한다](%EB%8D%94%20%EC%9D%B4%EC%83%81%EC%9D%98%20%EC%9E%90%EC%84%B8%ED%95%9C%20%EC%84%A4%EB%AA%85%EC%9D%80%20%EC%83%9D%EB%9E%B5%ED%95%9C%EB%8B%A4.md)
  * `[11]` 이러한 아이디어를 발전시킨 것이 CORBA와 MS의 COM/DCOM/COM+이다. 최근에는 SOAP나 JSON, XML-RPC등 텍스트 기반의 직렬화 기술도 많이 사용된다. Java에는 Java Runtime 끼리 통신하기 위한 RMI(Remote Method Invocation)도 지원한다.

