## Contents

    

1. [영어](%EC%98%81%EC%96%B4.md) 단어 
2. [컴퓨터](%EC%BB%B4%ED%93%A8%ED%84%B0.md) 용어 
    

2.1. 정의

2.2. 종류

    

2.2.1. RAID 0

2.2.2. RAID 1

2.2.3. RAID 2, 3, 4

2.2.4. RAID 5

2.2.5. RAID 6

2.2.6. 그 외의 RAID Level

    

2.2.6.1. JBOD

2.2.6.2. Nested RAID

2.3. 개인 환경에서의 사용

2.4. Hot Spare

2.5. 성능 비교

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=1)]

# 1. [영어](%EC%98%81%EC%96%B4.md) 단어 ¶

'약탈하다'라는 뜻이다. [레이드](%EB%A0%88%EC%9D%B4%EB%93%9C.md) 참조.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=2)]

# 2. [컴퓨터](%EC%BB%B4%ED%93%A8%ED%84%B0.md) 용어 ¶

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=3)]

## 2.1. 정의 ¶

**R**edundant **A**rray of **I**nexpensive/**I**ndependent **D**isks  
저장장치 여러 개를 묶어 고용량·고성능 저장 장치 한 개와 같은 효과를 얻기 위해 개발된 기법이다.

  

초기에는 업그레이드 후 '폐기하기엔 아깝고, 그렇다고 단독으로 쓰기에는 성능이 부족한'(Inexpensive) 저장장치를 재활용할 목적으로
사용하였다. 저장장치 기술이 발전한 현재는 Inexpensive보다는 Independent로 해석하는 추세.

  

RAID의 주 사용 목적은 크게 **무정지 구현**(안정성)과 **고성능 구현**으로 구분된다. 무정지 구현을 극도로 추구하면 RAID 1,
고성능 구현을 극도로 추구하면 RAID 0이 되며, RAID 5, 6은 둘 사이에서 적당히 타협한 형태.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=4)]

## 2.2. 종류 ¶

동작 방식에 따라 Level 0 ~ 6으로 분류한다. 주로 사용되는 것은 0, 1, 5, 6이며 컨트롤러 개발사에 따라 다른 방식을
제공하기도 한다.

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=5)]

### 2.2.1. RAID 0 ¶

Striping.

  

여러 개의 멤버 [하드디스크](%ED%95%98%EB%93%9C%EB%94%94%EC%8A%A4%ED%81%AC.md)를 병렬로
배치하여 거대한 하나의 디스크처럼 사용한다. 데이터 입출력이 각 멤버 디스크에 공평하게 분배되며, 디스크의 수가 N개라면 입출력 속도 및
저장 공간은 이론상 N배가 된다. 다만 멤버 디스크 중 하나만 손상 또는 분실되어도 전체 데이터가 파손되며, 오류검출 기능이 없어 멤버
디스크를 늘릴수록 안정성이 떨어지는 문제가 있다.

  

이미지 프로세싱, 데이터베이스 캐시 등 빠른 입출력 성능을 필요로 하며, 데이터 손실이 문제되지 않는 환경에서 쓰일 수 있지만, 상용
환경에서는 위험성 문제로 RAID 5나 6을 이용하는 경우가 많다고 한다.

  

이 때문에 고성능을 경험하고 싶은 파워유저가 구축해 보는 경우가 많다. [SSD](SSD.md)를 단독 사용하기에는 용량이 많이
부족하니, 여러 개를 묶어서 초고속 저장 장치를 구축하는 것. 이런 점을 간파하고 컴퓨터 제조 업체에서 공식적으로 RAID0 기술을 구현한
최초의 사례로는 [소니](%EC%86%8C%EB%8B%88.md)의 노트북 브랜드인 [VAIO](VAIO.md)의 프리미엄 모델인
Z 시리즈가 최초`[1]`인데, 노트북 업계 최초로 SSD로 RAID0 기술을 구현했으며, 앞으로도 소니는 자사의 프리미엄 노트북 라인업에
이 RAID0 기술을 구현한 SSD를 계속 탑재 할 전망이다.`[2]`<del>하지만 소니는 2014년 현재 노트북 사업부를
매각했다(...)</del>

  
  

  

[VAIO](VAIO.md) Z시리즈의 홍보영상에서 RAID0(0^4) SSD와 5400rpm 2.5인치
[하드디스크](%ED%95%98%EB%93%9C%EB%94%94%EC%8A%A4%ED%81%AC.md)를 비교대상으로 놓고 1GB
용량의 파일을 복사하는데 걸리는 시간을 측정하는 장면이 있는데 RAID0 SSD의 경우 **1GB 파일을 복사하는데 걸리는 시간이 겨우
4초**에 불과할 정도로 엄청난 속도다. 사실 VAIO Z에 장착된 SSD의 경우 일반적인 공식 SSD 규격이 아닌 소니의 자체적인 소형화
규격으로 재설계하였기 때문에 그 비좁은 메인보드 공간 안에 탑재 될 수 있었던 것이다.`[3]` 국내에서 판매되었던 VPCZ1의 일반형
모델의 경우 용량이 128GB로서 64GB SSD 두 개를 RAID0로 묶은 것이며, 고급형 모델의 경우 용량이 256GB로서 64GB
SSD 4개를 RAID0로 묶은 형태다. 게다가 일본 내수용 주문제작 방식의 오너메이드의 모델의 경우, 현재 RAID0로 128GB SSD
4개를 묶은 512GB 용량과, 256GB SSD 4개를 묶은 1TB 용량까지도 선택이 가능하다. 물론 이들을 선택하면 견적이 어마어마하기에
이를 선택하는 사람은 실제로 얼마나 될 지 의문이지만...

  

삼성의 **[SSD](SSD.md) 24개를 한 개의 볼륨으로 묶기** 같은 것도 할 수 있으며, **2.0GB/s**(Gb가
아니다!)의 속도가 나오는 6[TB](TB.md)볼륨을 구축한 삼성 SSD [광고
영상](http://www.youtube.com/watch?v=96dWOEa4Djs)도 있다.  
여담이지만 2009년에 찍힌 저 광고영상의 속도를 달성하려면 2013년 4월 기준으로 삼성 840Pro 256G 4~6개만으로도 동등하거나
더 빠른 속도를 낼 수 있다.

  

RAID 0의 경우 Stripe size를 지정할 수 있다. 컨트롤러에 따라 다르지만 Intel RST에서는 4~128KB를 지원한다. 이
Stripe size는 기록시 한 디스크에 한번에 기록할 데이터 크기이다. 즉, Stripe size가 4KB이고, 멤버 디스크가 4개라면
16KB짜리 파일을 기록할때 디스크당 4KB씩 돌아가면서 한 번씩 기록한다. Stripe size가 128KB이고, 멤버 디스크가 2개,
기록할 파일이 2MB(2048KB)라면, 첫 번째 디스크에 128KB, 두 번째 디스크에 128KB를 순차적으로 기록하는 것을 디스크당
8번씩 반복한다. SSD에서는 128KB 이상이 추천되며, 하드디스크라면 32KB정도가 추천된다. 하지만 사용자의 환경에 따라 최적의 성능을
내는 Stripe size가 다르므로 하나하나 적용해 보는것이 좋다.

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=6)]

### 2.2.2. RAID 1 ¶

Mirroring.

  

각 멤버 디스크에 같은 데이터를 중복 기록한다. 멤버 디스크 중 하나만 살아남으면 데이터는 보존되며 복원도 1:1 복사로 매우 간단하기
때문에, 서버 또는 연구목적 PC에서 혹시 모를 데이터 손실에 대비하기 위해 사용한다.

  

멤버 디스크를 늘리더라도 저장 공간은 증가하지 않으며, 대신 안정성이 크게 증가하게 된다. 상용 환경에서는 디스크를 2개 이상 쓰는 경우가
드물지만, 극한 환경에서는 3개 이상의 멤버 디스크를 사용하기도 한다. 데이터 가치가 하드디스크 가격이 껌값으로 여겨질 정도로 높은 경우
사용한다. 읽기 성능은 약간 향상되지만, 쓰기 성능은 약간 떨어진다.

  

데이터 복구 서비스를 쓰면 되지 않냐고 반박할 수도 있지만,  

  1. 복구에 장시간이 소모됨
  2. 데이터를 100% 복구하기 어려움
  3. 극비 데이터의 유출 가능성
등의 이유로 복구 서비스에만 의존할 수는 없기 때문에 RAID 1을 쓰는 것이다. 아예 데이터를 중복 저장해서 하드가 망가졌을 때 백업 등
최소한의 대처할 시간을 버는 것. 그런데 한가지 주의할 점이 있는데 RAID 1 사용 중 HDD Fail 발생시 최우선 순위는 하드 교체가
아니고 **데이터 백업**이다. RAID 1을 구성할 때에는 같은 제조회사의 같은 모델 같은 주차 생산품을 쓰게 되는데(그게 권장되기도
하고) 이 말은 한쪽이 맛간 상태면 다른 쪽도 맛가기 일보직전 상황일 확률이 크다는 얘기가 된다. 이 상태에서 디스크만 교체하면 RAID
컨트롤러가 리빌드(Rebuild)작업을 하면서 남은 한쪽의 하드디스크에 큰 부담을 주게 되고 결국 리빌드 중간에 남은 하나의 하드마저
뻗어버리는 사태를 당하게 된다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=7)]

### 2.2.3. RAID 2, 3, 4 ¶

Fault Tolerance using Dedicated Parity Bit.

  

오류정정부호(ECC)를 기록하는 전용의 하드디스크를 이용해서 안정성을 확보한다. RAID 2는 비트 단위에 Hamming code를
적용하며, RAID 3, 4는 각각 바이트, 워드 단위로 패리티를 저장한다. 하나의 멤버 디스크가 고장나도 ECC를 이용하여 정상적으로
작동할 수 있지만, 추가적인 연산이 필요하여 입출력 속도가 매우 떨어진다.

  

모든 I/O에서 ECC 계산이 필요하므로 입출력 병목 현상이 발생하며, ECC 기록용으로 쓰이는 디스크의 수명이 다른 디스크들에 비해
짧아지는 문제가 있어 현재는 사용하지 않는다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=8)]

### 2.2.4. RAID 5 ¶

Fault Tolerance using Distributed Parity Bit.

  

기본 원리는 RAID 4와 비슷하나, 패리티를 한 디스크에 밀어넣지 않고 각 멤버 디스크에 돌아가면서 순환적으로 저장하여 입출력 병목현상을
해결한다. N개의 디스크를 사용하면 (N-1)배의 저장 공간을 사용할 수 있다. RAID 4처럼 하나의 멤버 디스크 고장에는 견딜 수 있지만
디스크가 두 개 이상 고장나면 데이터가 모두 손실된다.

  

매번 쓰기 작업 때마다 패리티 연산 과정이 추가되어, 성능을 보장하려면 고가의 패리티 연산 전용 프로세서와 메모리를 사용해야 한다. 멤버
디스크도 최소 3개 이상 사용해야 하므로 초기 구축비용이 비싸다는 단점이 있다. 다만 멤버 디스크의 수가 5개 이하인 중소규모 파일서버라면
소프트웨어 RAID도 괜찮다. 부팅용 하드가 별도로 필요하다는 게(그리고 부팅하드가 뻑나면 RAID까지 풀려서 복구하기 짜증난다는)
애로점이긴 하지만...

  

읽기 작업은 전체 디스크에 분산되어 속도가 향상되지만, 쓰기 작업은 적어도 둘 이상의 디스크(데이터+패리티)에서 진행되어야 하므로 성능이
약간 떨어진다.

  

데이터베이스 서버 등 큰 용량과 무정지 복구 기능을 동시에 필요로 하는 환경에서 주로 쓰인다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=9)]

### 2.2.5. RAID 6 ¶

Fault Tolerance using Distributed Double Parity Bit.

  

RAID 5와 원리는 같으며, 서로 다른 방식의 패리티 2개를 동시에 사용한다. 성능과 용량을 희생해서 안정성을 높인 셈. N개의 디스크를
사용하면 (N-2)배의 저장 공간을 사용할 수 있다.

  

스토리지 서버와 같이 디스크를 빼곡히 꽂는(기본 10개 단위) 환경에서 RAID 5는 유지보수가 어려우며`[4]`, 안정성을 높이기 위한
목적으로 주로 사용된다. 컨트롤러가 RAID 5보다 더 비싸고, 멤버 디스크도 기본 4개 이상 확보해야 하므로 초기 구축비용이 비싸다.

  

하드디스크를 대단위로 물려야 하고, 데이터 안정성의 필요성이 RAID 5보다 높아야 하는 상황에서 쓰인다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=10)]

### 2.2.6. 그 외의 RAID Level ¶

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=11)]

#### 2.2.6.1. JBOD ¶

Just Bunch of Disks.

  

그냥 여러 디스크를 하나의 디스크처럼 보이게 수평적으로 섹터를 이어붙인 개념이다. RAID0처럼 멤버 디스크 중 하나만 깨져도 모든 데이터가
손실되지는 않고 고장난 디스크에 해당하는 부분만 날아간다. 때문에 로그 기록같이 부분적으로 데이터가 파손되어도 괜찮은 환경에서 가끔
사용된다.`[5]`

  

디스크를 Spanning한 환경이기 때문에 다중 사용자 환경에서 분산도가 높은 데이터를 다루는 경우 RAID0에 근접하는 성능을 얻을 수도
있으나... 현실은 20%의 핵심 데이터에 모든 액세스가 집중되므로 현실은 시궁창... 같은 환경에서 RAID0은 20%의 핫존이 모든
디스크에 고루 분포돼있지만 JBOD는 한두개의 디스크에 몰려있다.

  

RAID는 모든 멤버 디스크의 성능(저장 공간이나 I/O 성능 등)이 같은 환경을 전제하기 때문에 멤버 디스크 성능에 차이가 있으면,
**가장 낮은 성능**으로 하향 평준화된다. (예를 들어 100GB짜리와 74GB짜리 하드디스크를 RAID 0으로 묶으면 74 × 2인
148GB만 쓸 수 있고, 26GB는 버려진다) 반면 JBOD는 멤버 디스크의 성능이 서로 달라도 무방하므로 어떻게
[돈지랄](%EB%8F%88%EC%A7%80%EB%9E%84.md)을 해도 저장해야 할 데이터 크기만큼의 하드를 확보할 수 없을
때`[6]`에 쓴다.

  

이러한 문제로 [Western Digital](WD.md)社에서는 Raid Edition 이라는 기업 대상 레이드 전용 제품군을 출시한
적도 있다. 이 녀석은 무상 A/S기간도 5년이나 된다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=12)]

#### 2.2.6.2. Nested RAID ¶

레이드 볼륨의 멤버로 다른 레이드 볼륨을 사용하는 형태. 볼륨 확장 과정에서 구성 편의성 문제로 형성되는 경우가 많다. 이 때 멤버 디스크를
묶는 배열을 하위 배열, 하위 배열을 묶는 배열을 상위 배열이라고 한다.

  

대표적인 예시로 10, 0+1, 15, 50, 0+5, 51 등이 존재한다. 표기 방법은 m(하위 배열)n(상위 배열)이다.  
아래 예시는 1TB 디스크 6개로 구성한다는 상황을 가정하여 작성해 두었다.

  

  * RAID 10  
하위 배열은 RAID 1, 상위 배열은 RAID 0이다. RAID 1로 미러링 된 볼륨을 RAID 0으로 스트라이핑 한다.  
퍼포먼스 및 용량 위주로 구성한다면, 디스크 2개를 RAID 1로 묶은 미러 볼륨 3개를 RAID 0으로 스트라이핑 한다. 이 경우 사용
가능한 총 용량은 3TB가 된다.  
안정성 위주로 구성한다면, 디스크 3개를 RAID 1로 묶은 미러 볼륨 2개를 RAID 0으로 스트라이핑 한다. 이 경우 사용 가능한 총
용량은 2TB가 된다. RAID 0+1에 비해 디스크 장애 발생시 복구가 수월하다.

  * RAID 0+1  
하위 배열은 RAID 0, 상위 배열은 RAID 1이다. RAID 0으로 스트라이핑 된 볼륨을 RAID 1로 미러링 한다.  
퍼포먼스 및 용량 위주로 구성한다면 디스크 3개를 RAID 0으로 묶은 스트라이프 볼륨 2개를 RAID 1로 미러링 한다. 이 경우 사용
가능한 총 용량은 3TB가 된다.  
안정성 위주로 구성한다면, 디스크 2개를 RAID 0으로 묶은 스트라이프 볼륨 3개를 RAID 1로 미러링 한다. 이 경우 사용 가능한 총
용량은 2TB가 된다.  
RAID 10에 비해 RAID 볼륨이 깨졌을 경우 복구가 힘들다. RAID 10과 비교하자면, 미러 볼륨으로 구성된 어레이에서 디스크 하나가
고장이 났다면, 미러 볼륨 자체는 깨지지 않는다. 즉, 디스크만 바꿔 넣어주면 알아서 Rebuliding 하여 원래 상태로 돌아간다. 하지만
RAID 0+1의 경우 디스크 하나가 고장이 났다면, **해당 RAID 0 어레이 전체가 깨져버린다.** 디스크를 교체한 뒤, RAID 0
어레이를 다시 구성하고 다시 미러링 해야 한다.

  * RAID 15  
하위 배열은 RAID 1, 상위 배열은 RAID 5다. 개인 사용자 레벨에서는 사용할 일이 거의 없는 RAID 레벨이다. RAID 1로
미러링 된 볼륨을 RAID 5 볼륨으로 묶는다. RAID 5의 경우 최소 3개 이상의 디스크가 필요하기 때문에 디스크 6개로 구성할 수 있는
경우의 수는 하나밖에 없다.  
디스크 2개를 RAID 1로 묶은 미러 볼륨 3개를 RAID 5로 묶는다. 이 경우 사용 가능한 총 용량은 2TB가 된다.

  * RAID 50  
하위 배열은 RAID 5, 상위 배열은 RAID 0이다. 마찬가지로 개인 사용자 레벨에서는 사용할 일이 거의 없다. RAID 5 볼륨을
RAID 0으로 스트라이핑 한다. 마찬가지로 RAID 5의 경우 최소 3개 이상의 디스크가 필요하기 때문에 디스크 6개로 구성할 수 있는
경우의 수는 하나밖에 없다.  
디스크 3개를 RAID 5 볼륨으로 묶은 것을 RAID 0으로 스트라이핑 한다. 이 경우 사용 가능한 총 용량은 4TB가 된다.  
RAID 0+5에 비해서 디스크 장애 발생 시 복구가 수월하다.

  * RAID 0+5  
하위 배열은 RAID 0, 상위 배열은 RAID 5이다. 역시 개인 사용자 레벨에서는 사용할 일이 거의 없다. RAID 0 볼륨을 RAID
5 볼륨으로 묶는다. 역시 RAID 5의 경우 최소 3개 이상의 디스크를 필요로 하므로 디스크 6개로 구성할 수 있는 경우의 수는 하나밖에
없다.  
디스크 2개를 RAID 0으로 묶은 스트라이프 볼륨 3개를 RAID 5로 묶는다. 이 경우 사용 가능한 총 용량은 4TB가 된다.  
RAID 50에 비해 장애 조치가 힘들다. 이유는 RAID 0+1에도 나와 있지만 디스크 장애 발생시 해당 RAID 0 볼륨이 깨져버리기
때문.

  * RAID 51  
하위 배열은 RAID 5, 상위 배열은 RAID 1이다. 이 역시 개인 사용자 레벨에서는 사용할 일이 거의 없다. RAID 5 볼륨을
RAID 1로 미러링 한다. 역시 RAID 5 볼륨의 경우 디스크 3개 이상을 필요로 하므로 역시 구성할 수 있는 경우의 수는 하나밖에
없다.  
디스크 3개를 RAID 5 볼륨으로 묶고, 그 볼륨 두개를 RAID 1로 미러링 한다. 이 경우 사용 가능한 총 용량은 2TB가 된다.
RAID 15나 51이나 장애 발생시 복구하는 데 필요한 노력은 비슷하다. RAID 1 환경에서 디스크가 깨진 경우에도 디스크를 교체해 주면
Rebuilding 하여 복구가 되지만, 그건 RAID 5도 마찬가지다.

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=13)]

## 2.3. 개인 환경에서의 사용 ¶

전통적으로 별도의 RAID 컨트롤러를 사용하는 것이 안정성이 좋고 유지보수 등에 있어서 간편한 것으로 알려져 있으나, 최근의 메인보드 내장
RAID 컨트롤러 또한 상당한 성능을 보여주고 있다. 인텔의 경우 Intel Rapid Storage Technology라고 부르는 그것.
많이 나아지긴 했지만, 내장 컨트롤러라는 한계가 있어 여러 디스크를 RAID 0으로 묶을 경우 제 성능을 못 내는 경우도 있다. 안정성
면에서도 별도의 RAID 컨트롤러에 비해 부실하기 때문에 RAID 1을 제외하면 RAID Array가 깨졌을 시 데이터 복구는 포기하는게
편하니 주의하도록 하자.

  

흔히 [파코즈](%ED%8C%8C%EC%BD%94%EC%A6%88.md)나 [2CPU](2CPU.md) 등에서 이를 구축한 사람을
쉽게 볼 수 있다. 만약 하드디스크 사망으로 인한 데이터 손실을 경험해 보았다면, RAID 1 정도는 구축해 보아도 나쁘지 않을 것이다.
물론 용량 및 성능 대비 금액 크다는 단점이 있다.

  

최근들어 NAS 의 보급으로 인해 개인환경에서 사용하는 경우도 많아졌다. 주로 사진과 같이 다량의 데이터를 보관하거나 미디어 서버의 용도로
사용하는 경우가 많은데 예전에 비해 많이 저렴한 가격으로 사용할 수 있다. 또한 4-bay 이상의 NAS 도 많이 저렴`[7]`해져 개인
level 에서 RAID 5 이상을 구현하는 경우도 예전보다는 늘었다.

  

하지만, 명심해야 할것은 **레이드는 백업이 아니다!**. 실제로 저 문구는 레이드를 설명하는 글에서 자주 등장한다. 데이터 안정성 목적으로
레이드는 전통적인 백업을 절대로 대체하지 못하며, 데이터 안정성보다는 디스크 몇 개가 고장나서 갈아끼워야 할때도 나머지 디스크로 중단없이
서비스를 하려는 목적이 오히려 더 강하다. 사실 하드디스크가 뻑날 확률은 디스크 개수만큼, 그리고 돌아가는 시간만큼 뻥튀기가 되기 때문에
수십개를 주렁주렁 달아놓고 24시간 돌아가는 서버의 경우에는 커다란 문제이고 레이드가 가뭄에 단비와도 같은 존재지만, 4-5개 정도의
디스크만 사용하며 실제 하드디스크를 사용하는 정도도 훨씬 덜한 개인 사용자들의 경우에는 사실 디스크가 뻑나서 날려먹는 경우보다 본인 실수로
잘못 지운다거나 해서 날려먹는 경우가 훨씬 많다고 볼 수 있다. 이 때문에 개인사용자의 경우에는 레이드보다 백업이 훨씬 가치가 크다.
레이드에 대한 지식이 별로 없는 개인사용자들이 흔히 범하는 실수가, 몇개 안되는 디스크로 데이터 안정성을 목적으로 백업 없이 4개 정도의
디스크를 RAID 1로 구축해 버리는 경우다. 차라리 안정성 구현을 원한다면 RAID 10을 구성하고 주기적으로 백업하는 편이 훨씬 낫다.  
소비자수준에서는 RAID 5로 적절한 가격에 적절한 신뢰성과 용량확장을 노릴 수도 있다. 하지만 제대로 RAID를 하기 위해 컨트롤러를 따로
구매하면 가격은 가격대로 비싸지고, 막상 RAID를 묶어놔도 방치되다가 관리소홀로 두개가 죽을때까지 모르다가 데이터만 날리는 경우도 있다.
대부분 같은 시기에 생산된 같은 하드디스크를 이용하기때문에 하나죽으면 다른것도 비슷한 시기에 죽을 확률이 높다. 그냥 수작업으로 백업하면서
디스크에 필요없는 <del>그녀</del>것들좀 지우고 정리나 하자.

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=14)]

## 2.4. Hot Spare ¶

RAID 5, 6, 1 등 소수의 하드디스크가 고장나더라도 운영에 지장이 없는 RAID Level 을 위해 존재한다. Hot Spare 는
전체 멤버디스크에서 1개 이상의 디스크를 spare 로 지정해서 data를 읽고 쓰는 행위를 하지 않고 그냥 대기(stand-by) 시키다가
디스크가 고장 났을때 자동으로 rebuilding 하여 원래의 raid 상태로 복구`[8]`시킨다.

  

일반적으로 RAID 1 에서는 2 + 1 의 구성으로, RAID 5 에서는 멤버디스크+1로, RAID 6 에서는 멤버디스크 + 2 로
구성하며 Hot Spare 는 사용하지않고 노는 disk 를 양산하기 때문에 구성 disk 대비 사용 용량이 매우 적고 비용이 증가한다. 단
안전성을 좀 더 높일 수 있다. 또한 raid group 을 여러개 지정하는 중형 이상의 storage에서는 Global Spare 라 하여
여러 group 이 공용으로 Hot Spare 를 사용하게 하는 경우도 있다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/RAID?action=edit&section=15)]

## 2.5. 성능 비교 ¶

이론상 최적화되었을 때의 비교값이다.

  

  * 안정성 : 1 >> 6 > 5 > non-RAID >> 0 > 0^3 > 0^4 ······  

    * 멤버 디스크가 하나라도 망가지면 데이터 전체가 날아가는 만큼 RAID 0은 묶은 디스크의 개수가 많아질수록 안정성이 떨어진다.
  * 읽기속도 : ······ 0^4 > 0^3 > 0 > 1 > 5 ≥ 6 >> non-RAID.  

    * 멤버 디스크 개수가 늘어날수록 속도는 더더욱 빨라진다.
  * 쓰기속도 : ······ 0^4 > 0^3 > 0 > 5 ≥ 6 > non-RAID ≥ 1  

    * 사실 쓰기 속도의 증가는 기대하지 않는 게 좋다.
  * 가격대비 용량 : non-RAID = 0 > 5 > 6 > 1
  * 초기구축비용 : 6 > 5 > 1 > 0 = non-RAID.  
일반적인 개인/SOHO 환경을 기준으로 했을 때의 이야기이다. 하드디스크가 서버랙 전체에 빼곡히 꽂혀나가는 상황이라면 의미가 없는 것이나
마찬가지.

`\----`

  * `[1]` 엄밀히는 Z의 초기 시리즈인 VGN-Z의 라인업에서 고급형 모델에 한시적으로 탑재된 것이 시초이며, 본격적으로 적용되기 시작한 것은 후속 라인업인 VPCZ1에서라고 할 수 있다.
  * `[2]` 소니의 2011년 신모델로 나온 바이오 SB 시리즈의 고급형 모델의 경우 128GB SSD 두 개를 RAID0로 묶어서 256GB의 용량을 가진다.
  * `[3]` 참고로 바이오 Z(VPCZ1)는 13인치급 노트북이지만 배터리 포함 무게는 1.4kg 정도로 넷북과 맞먹는 수준이며, ODD까지 내장하고 있어서 실제 메인보드가 장착되는 면적은 본체 면적의 절반 정도에 불과하다.... [흠좀무](%ED%9D%A0%EC%A2%80%EB%AC%B4.md)
  * `[4]` 하드 하나가 고장난 RAID 5 장비에서 교체하려다가 실수로 멀쩡한 하드 하나를 뽑았다 → 데이타는 천국으로. 동일 상황에서 RAID 6는 문제가 없다.
  * `[5]` 가끔이라는 이유는 굳이 로그용 디스크를 따로 할당하는 경우가 별로 없기 때문. 그냥 RAID5 볼륨에서 로그까지 기록하는 경우가 많다
  * `[6]` 예를 들면 과거 HDD의 용량단위가 MB 단위로 나오던 시절
  * `[7]` 2011년 4월 기준 2베이 정도는 20-30 에도 NAS 본체를 구입 가능하며 4 베이 이상은 100 만원 정도부터 시작. 2-3년 전에 비해 정말 정말 저렴해졌다.
  * `[8]` 그렇다고 고장난 하드를 안바꾸는건 아니지만 아무래도 다시 또하나의 디스크가 고장 났을때 그만큼의 시간을 벌 수 있다.

