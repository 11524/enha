整列 / Range

## Contents

    

1. 정렬(整列) 
2. 정렬 문제(Sorting Problem) 
    

2.1. 대표적인 정렬의 종류

    

2.1.1. O(n2)인 것

2.1.2. O(n_lg_n)인 것

2.1.3. 그 밖에

2.2. 참고 항목

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%A0%95%EB%A0%AC?action=edit&sect
ion=1)]

## 1. 정렬(整列) ¶

뭔가가 주어졌을 때 이것을 정해진 순서대로 가지런하게 나열하는 것을 의미한다. "가지런히 함"으로 순화할 것을 권고하고 있지만 사실
"정렬"이란 표현 자체가 학술쪽에서 오래 사용된 단어이고, 글자 수가 훨씬 적기 때문에<del>당연히</del> 잘 안고쳐진다.

  

나열하는 순서에 따라서 오름차순, 내림차순으로 구분한다. 사람들이 자주 헷갈려하는데 오름차순은 1 -> 2 -> 3 -> 4 -> …… 와
같이 뒤로 갈수록 숫자가 커지는 경우이고 내림차순은 그 반대이다. 정렬한 결과물을 선그래프로 그렸을 때 값이 작은 것을 앞으로 정렬하면
그래프의 선이 올라가므로(↗) 오름차순이고 값이 큰 것을 앞으로 정렬하면 그래프의 선이 내려가므로(↘) 내림차순이라고 생각하면 된다.
마찬가지로 어휘의 순서를 기반으로 가나다, ABC 순으로 나열하는 경우에는 오름차순이고, 그 반대의 경우에는 내림차순에 해당한다.

  

[리그베다 위키](%EB%A6%AC%EA%B7%B8%EB%B2%A0%EB%8B%A4%20%EC%9C%84%ED%82%A4.md)의
경우에도 항목을 작성하고 그에 관련된 하위 항목들을 기재할 때,
[대한민국](%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD.md)의
[행정구역](%ED%96%89%EC%A0%95%EA%B5%AC%EC%97%AD.md) 정렬`[1]` 등 특별한 경우가 아니면 보통
[가나다순](%EA%B0%80%EB%82%98%EB%8B%A4%EC%88%9C.md), ABC순 정렬을 권장하고 있다. 그러니깐 하위
항목 작성할 때 순서가 잘 갖추어져 있으면, 그냥 밑에다 쓰지 말고 정렬된 순서에 맞게 써주는 것이 좋다.

  

각 문자·언어별 정렬 순서는 [정렬/순서](%EC%A0%95%EB%A0%AC/%EC%88%9C%EC%84%9C.md) 항목을 참고할
것.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%A0%95%EB%A0%AC?action=edit&sect
ion=2)]

## 2. 정렬 문제(Sorting Problem) ¶

  * [컴퓨터 관련 정보](%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4.md)
  
  
<del>오오오오옹ㅇ오오오오오</del>  
<del>뽀오오오오오오옥ㄱ</del>  
정렬 알고리즘을 소리로 표현한 영상이다. 15가지의 정렬이 나타나 있다.

  

컴퓨터 분야에서 중요시되는 문제 가운데 하나로 어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 문제이다. 실제 컴퓨터 분야에서
사용하는 데이터의 경우 숫자의 순서나 어휘의 순서대로 정렬한다음 사용해야되는 경우가 거의 항상 발생하는데 이걸 얼마나 효과적으로 해결할 수
있느냐가 정렬 문제의 핵심이다.

  

데이터를 정렬해야하는 이유는 간단하다. 사람의 경우 많은 숫자들이 무작위로 주어지고 "이 중에서 [42](42.md)를 찾아주세요"라고
한다면 한 번 스윽보고 찾을 수 있지만 컴퓨터는 그런 거 못한다. 주어진 숫자들을 처음 또는 뒤에서부터 순서대로 읽어보고 42가 나오면
그제서야 찾았다고 응답하는 수준이다. 숫자의 범위가 작고 한 두 번하는 거면 모를까 대개는 할 짓이 못된다. 하지만 이 값들이 정렬되어
있다면 컴퓨터 입장에서 아주 효과적인 방법을 이용하여 몇 번 훑어보지도 않고 찾아낼 수 있다.

  

보통 컴퓨터 분야에서 연구되는 문제들의 경우 사람들이 푸는 방식을 흉내내는 경우가 많은데, 정렬 문제 역시 사람들이 푸는 방식을 흉내낸
형태이다. 주어진 데이터들이 있으면 값들을 서로 비교하여 순서에 맞게 자리를 바꿔주는 형태로 정렬을 하는데 이를 "비교정렬"이라고 부른다.
일반적으로 많이 쓰이는 정렬방법이고 만들기도 굉장히 쉬운 편이다. 그 외에 비교를 하지 않고 데이터를 보는 순서대로 나열하는 방식이 있긴
한데 이는 조금 특수한 경우에만 사용할 수 있다. 아주 간단한 예로 우편함 방식을 들 수 있다. "이름을 봐야되니 비교를 하지 않나요?"라고
질문하는 경우가 있는데 아니다. 약간 조작하면 비교없이 바로바로 집어넣을 수 있다.

  

전문적인 이야기를 최대한 생략하고 설명하면 입력된 데이터의 크기를 n이라고 했을 때 비교정렬의 경우에는 n의 제곱만큼 비교를 해야 정렬이
되는데 알고리즘 연구하는 사람들 입장에서 보면 이게 비효율적인 방식이다. 그래서 온갖 수단과 방법을 동원해서 현재는 대략
(n_lg_n)`[2]`번 비교할 수 있도록 줄인 상태이고 비교정렬의 경우 여기서 더이상 줄일 수 없다고 증명되었다.`[3]` 사실 비교를
하지 않고 정렬하는 방법이 연구된 것도 비효율성 때문이다. 비교를 하지 않는 방법의 경우에는 입력의 크기를 n이라고 하면 n번만 읽으면
정렬이 되기 때문이다.

  

비전공자의 경우 "그게 뭐 그리 어려운 가요?"라고 생각하는 사람들이 많은데 아주 효과적인 정렬방법을 만들기 위해서는 온갖 잔머리와 테크닉,
지혜, 아이디어를 갈아넣어야 된다. 농담이 아니라 정렬 문제 하나만 파서 [박사](%EB%B0%95%EC%82%AC.md)학위까지 따는
경우도 있다. [빌 게이츠](%EB%B9%8C%20%EA%B2%8C%EC%9D%B4%EC%B8%A0.md)의 경우, 팬케이크 정렬을
구현하는 알고리즘을 냈는데 대체할 알고리즘이 나오기 까지 30여년이 걸렸다고,`[4]` 근래에는 많은 효과적인 정렬 방법들이 개발돼서 정말
획기적인 것을 제시하는 거 아니면 박사학위까지 가는 것은 좀 힘들긴 하겠지만…

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%A0%95%EB%A0%AC?action=edit&sect
ion=3)]

### 2.1. 대표적인 정렬의 종류 ¶

![qbsorting.png](//rv.wkcdn.net/http://rigvedawiki.net/r1/pds/qbsorting.png)

[PNG image (9.42 KB)]

  
빠른 순서대로 퀵-셸-교환-힙-버블-삽입. _빠른_ _조개_를 _교환_하니 _엉덩이_에서 _거품_이 나오는 _삽_을 주더라.`[5]`

  

실제 응용에서는 상황에 따라 두 가지 이상의 정렬 방법을 사용하는 경우가 많다. 예를 들면, 정렬 대상이 특정 크기 이하로 단편화될 때
까지는 퀵정렬을 쓰다가, 그 특정 크기 이하가 됐을 때에는 작은 규모에서 강점을 보이는 삽입정렬을 쓴다거나 <del>그리고 귀찮으면 버블이나
선택 정렬을 쓴다</del> <del>그리고 상사는 뒷목을 잡는다</del>. <del>사실 stl의 sort() 하나면 된다</del>

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%A0%95%EB%A0%AC?action=edit&sect
ion=4)]

#### 2.1.1. O(n2)인 것 ¶

대개 계산 시간이 정렬할 자료의 수의 제곱에 비례해서 늘어난다. 즉, 1만 개를 1초에 정렬하면 10만 개를 정렬하는 데에는 100초 정도가
필요하다.

  

  * 버블정렬(Bubble sort, 거품정렬)  
  
  

![http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif
?uselang=ko](http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_an
imation.gif)

[[GIF external image]](http://upload.wikimedia.org/wikipedia/commons/3/37/Bubb
le_sort_animation.gif)

  
버블정렬을 실행했을 때 나오는 그림  
  
1번째와 2번째 원소를 비교하여 정렬하고, 2번째와 3번째, …… ,n-1번째와 n번째를 정렬한 뒤 다시 처음으로 돌아가 이번에는
n-2번째와 n-1번째 까지 정렬…… 해서 최대 n(n-1)/2 번 정렬한다.`[6]``[7]`한번 돌때마다 마지막 하나가 정렬이 되므로
원소들이 거품이 올라오는 것처럼 보여 거품정렬이다. 파생형으로 홀수번째 돌때는 앞부터, 짝수번째는 뒤부터 훝는 칵테일 정렬(cocktail
sort)내지는 셰이커 정렬(shaker sort)이란 것도 있다. 당연하겠지만 이 쪽은 마지막과 처음이 번갈아가며
정렬된다.`[8]``[9]`  
거의 모든 상황에서 최악의 성능을 보여준다. 단, 이미 정렬된 자료에서는 1번만 돌면 되기 때문에 최선의 성능을 보여준다. 이미 정렬된
자료를 정렬하는 바보짓을 왜 하냐는 의문이 들 수 있지만, 정렬 알고리즘은 자료가 정렬되어 있는지 아닌지는 모르고 작동하기 때문에 의미가
있다.  
가장 손쉽게 구현하여 사용할 수 있으며, 소소한 용도에서는 사용빈도도 높은 편이다. 하지만 만들기가 쉽고 직관적일 뿐이지, 알고리즘적
관점에서 보면 대단히 비효율적인 정렬 방식이다. 다른 몇 가지 정렬 방식과 비교해도 효율이 대략
[시망](%EC%8B%9C%EB%A7%9D.md).  
  
그런데도 많이 쓰는 것은 보통 PC의 경우 성능이 좋다보니 입력량이 작으면 어지간한 비효율적인 방법도 씹어먹고 수행이 가능하며, 무엇보다
효과적인 정렬방식을 구현하는 것은 프로그래머 입장에서 귀찮기 때문이다 (...) 하지만 웬만큼 자료량이 커지면 버블 소트는 피하는 것이
좋다.`[10]` 요즘은 웬만한 프로그래밍 언어 내부에 온갖 꼼수를 다 갈아넣은 고효율의 정렬 알고리즘이 내장되어 있어, 그냥 인클루드해서
갖다 쓰기만 하면 되는 세상이라`[11]` 버블 정렬의 장점이 거의 없다. 내장 정렬이 더 편하거든 (...)  
  
거품정렬에서 파생된 형태로 콤브정렬(Comb sort)이 있다. 이쪽은 기본 형태는 버블정렬과 같지만 예를 들어 처음에 a`[`0`]`에서
10칸 띄워서 a`[`11`]`과 비교해서 치환하는 식으로 대상을 띄웠다가 한 바퀴 돌면 띄우는 간격을 좁혀서 정렬하는 방식이다. 이렇게
하면 버블정렬과 다를 게 없어졌을 시점엔 정렬이 거의 끝나 있는데, 이 단계까지 가는 동안 모양이 마치 닭의 볏을 닮았다 하여 콤브정렬이라는
이름이 붙었다. 이렇게 본다면 콤브정렬이 버블정렬보다 좋아 보이지만 단점이 있는데 버블정렬이 **stable sort**이지만 콤브정렬은
그렇지 못하다.  
  
여담으로 모 [양판소](%EC%96%91%ED%8C%90%EC%86%8C.md)에서 거품 정렬 알고리즘`[12]`을 본문에 넣은 사례가
있는데, 수준이 낮거나 그냥 [귀차니즘](%EA%B7%80%EC%B0%A8%EB%8B%88%EC%A6%98.md)에 시달리는 마법사인
모양이다. <del>아니 그래서 작품명이 뭔데</del>  
  

  * 선택정렬(Selection sort)  
  
  

![http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.
gif](http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animati
on.gif)

[[GIF external image]](http://upload.wikimedia.org/wikipedia/commons/b/b0/Sele
ction_sort_animation.gif)

  
선택정렬을 실행했을 때 나오는 그림  
  
버블정렬이 비교하고 바로 바꿔넣는걸 반복한다면 이쪽은 일단 1번째부터 끝까지 훝어서 가장 작은게 1번째, 2번째부터 끝까지 훝어서 가장
작은게 2번째……해서 (n-1)번 반복한다. 어찌보면 인간이 사용하는 정렬 방식을 가장 많이 닮아 있다. 어떻게 정렬이 되어 있든 일관성있게
n(n-1)/2에 비례하는 시간이 걸린다는게 특징. 또한 버블정렬보다 시스템 자원을 적게 잡아먹는다.  

  * 삽입정렬(Insertion sort)  
  
  

![http://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-
300px.gif](http://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-
example-300px.gif)

[[GIF external image]](http://upload.wikimedia.org/wikipedia/commons/0/0f
/Insertion-sort-example-300px.gif)

  
삽입정렬을 알기 쉽게 만든 그림  
  
k번째 원소를 1~k-1까지와 비교해 적절한 위치에 끼워넣고 그 뒤의 자료를 한 칸씩 뒤로 밀어내는 방식으로, 평균적으론 O(n2)중
빠른편이나`[13]` 자료구조에 따라선 뒤로 밀어내는데 걸리는 시간이 크며, 앞의 예시처럼 작은게 뒤쪽에 몰려있으면(내림차순의 경우 큰게
뒤쪽에 몰려있으면) 그야말로 헬게이트다.  
다만 이미 정렬되어 있는 자료구조에 자료를 하나씩 삽입/제거하는 경우에는, 현실적으로 최고의 정렬 알고리즘이 되는데 탐색을 제외한 오버헤드가
매우 적기 때문이다. <del>괜히 '삽입'이란 이름이 붙은 것이 아니다.</del>  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%A0%95%EB%A0%AC?action=edit&sect
ion=5)]

#### 2.1.2. O(n_lg_n)인 것 ¶

이 세 알고리즘은 최선이나 평균적으로나 O(n_lg_n)의 성능을 나타낸다. 최악의 상황에서도 병합정렬이나 힙정렬은 O(n_lg_n)을
유지하는 반면 퀵정렬이 오히려 O(n2)으로 뒤지나, 실제 응용에서는 최악의 경우는 잘 발생하지 않는다.그럼에도 불구하고, 병합정렬이나
힙정렬 같은 다른 O(n_lg_n) 성능의 알고리즘은 요건에 따라서 어느 정도 퀵정렬과 대적할 만하다`[14]`.<del>애초에 퀵정렬
하위호환이였으면 예시로 나올리가 없지</del>

  

  * 병합정렬(Merge sort)  
  
  

![http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-
300px.gif](http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-
example-300px.gif)

[[GIF external image]](http://upload.wikimedia.org/wikipedia/commons/c/cc
/Merge-sort-example-300px.gif)

  
병합정렬의 예  
  
개발자는 [존 폰 노이만](%EC%A1%B4%20%ED%8F%B0%20%EB%85%B8%EC%9D%B4%EB%A7%8C.md)으로
원소개수가 1 또는 0이 될때까지 두 부분으로 자른뒤 자른 순서의 역순으로 크기를 비교해 병합해 나간다. 병합된 부분 안은 이미 정렬되어
있으므로 전부 비교하지 않아도 제자리를 찾을 수 있다. 대표적인 분할 정복 알고리즘으로 존 폰 노이만의 천재성을 엿볼 수 있는 알고리즘이다.  
  
성능은 아래의 힙정렬과 퀵정렬보다 전반적으로 뒤떨어지는데, 이유는 임시배열에 저장해두고 다시 찾는 과정에서 시간이 더 걸린다. 하지만 최대의
장점은 **stable sort**라는 점이다. 힙이나 퀵의 경우에는 배열 A`[25]`=100, A`[33]`=100인 정수형 배열을
정렬한다고 할 때, 33번째에 있던 100이 25번째에 있던 100보다 앞으로 오는 경우가 생길 수 있다. 그에 반해서 병합정렬은 [그런 거없다](%EA%B7%B8%EB%9F%B0%20%EA%B1%B0%20%EC%97%86%EB%8B%A4.md).`[15]`  

  * [힙](%ED%9E%99%20%ED%8A%B8%EB%A6%AC.md)정렬(Heap sort)  
  
`[16]`  
우선 힙이 뭔지 모른다면 [힙 트리](%ED%9E%99%20%ED%8A%B8%EB%A6%AC.md) 항목 참고.  
  

    1. 원소들을 전부 힙에 삽입한다
    2. 힙의 루트에 있는 값은 남은 수들 중에서 최소값(혹은 최대값)을 가지므로 루트를 출력하고 힙에서 제거한다.
    3. 힙이 빌 때 까지 2의 과정을 반복한다.  

![http://upload.wikimedia.org/wikipedia/commons/f/fe/Heap_sort_example.gif](ht
tp://upload.wikimedia.org/wikipedia/commons/f/fe/Heap_sort_example.gif)

[[GIF external image]](http://upload.wikimedia.org/wikipedia/commons/f/fe/Heap
_sort_example.gif)

  
  
사실 삽입 정렬과 거의 같은 알고리즘으로. 단지 자료 구조로 일반 배열을 사용하느냐 힙을 사용하느냐가 유일한 차이점이다.  
  
힙정렬은 최악의 경우에 O(n2)의 성능을 내는 퀵정렬과 달리 항상 O(n_lg_n) 정렬의 성능을 발휘하는 장점이 있어 이론적으로는
퀵소트와 같거나 더 좋은 성능을 내야 하지만 <del>현실은 시궁창이다</del> 실제 코드를 짜서 비교를 해 보면 퀵소트가 30% ~
40% 정도 빠르게 동작하며, 이것은 동작원리상 주변의 원소들과 교환이 잦은 퀵소트가 캐시적중률이 높아 교환 속도에서 이득을 보기 때문인
것으로 알려져 있다.  
  
재귀방식으로 작성되는 퀵소트가 대량의 원소를 정렬할 때 콜스택이 과도하게 깊어져 오류를 일으키는 경우가 있는 반면에, 재귀를 사용하지 않는
힙소트는 이러한 문제가 없다는 장점도 있다. <del>하지만 요즘은 퀵소트도 재귀 안쓰고 만들잖아? 그러니까 아마 안될거야..</del>  
  
  

  * 퀵정렬(Quick sort)  
  
  

![http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gi
f](http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.g
if)

[[GIF external image]](http://upload.wikimedia.org/wikipedia/commons/6/6a/Sort
ing_quicksort_anim.gif)

  
퀵정렬의 적절한 예시  
  
퀵이라는 이름에서 알 수 있듯이 평균적인 상황에서 최고의 성능을 나타낸다. 컴퓨터로 가장 많이 구현된 정렬 알고리즘 중 하나이다. ANSI
C에서 기본적으로 퀵소트를 지원하고`[17]`, 당연히 [C++](C++.md)과 C#, ,[PHP](PHP.md), 자바
등에서도… <del>당신이 쓰는 프로그래밍 언어가 기본 함수로 퀵소트를 지원하지 않는다면, 그다지 대단치 않은 언어일 가능성을 진지하게
생각해봅시다.</del> 방식은 적절한`[18]` 원소 하나를 기준(피벗, pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에
피벗을 옮겨 피벗보다 작은것, 큰것으로 나눈뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될때까지 정렬한다.  
  
위에서도 말했듯이 최악의 경우에는 시간복잡도가 O(n2)가 되는데, 대표적인 경우로는 <del>잘못 짠 경우</del> 이미 정렬이 완료된
경우`[19]`, 모든 값이 같은경우`[20]`가 대표적인 경우다. 힙정렬이나 병합정렬은 이런 경우가 없지만, 데이터가 극단적이면 대충
구현된 퀵정렬은 안쓰느니만 못한 최악의 결과를 초래한다. 이를 방지하기 위하여 여러 기법들이 개발 되었는데, 대표적인게 피벗을 랜덤으로 잡는
것. 또는, 배열 중에 3개나 9개의 원소를 골라서 이들의 중앙값을 피벗으로 고르는 것이다. `[21]` 이 방법을 사용하더라도 최악의
경우가 나올 수는 있지만 그 경우가 극히 드물게 된다.  
  
[링크드 리스트](%EB%A6%AC%EC%8A%A4%ED%8A%B8%28%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%29.md) 역시 퀵정렬이 가능하다. 첫번째 노드 A를 피봇으로 놓고 나머지 노드들 중 피봇보다 작은 것들은 L1, 큰 것들은 L2로
연결한다. L1과 L2를 퀵정렬한 뒤 L1->A->L2 순으로 연결하면 정렬 완료. 힙소트나 머지소트 역시 가능.  
  
단, [파이썬](%ED%8C%8C%EC%9D%B4%EC%8D%AC.md)은 퀵정렬을 하지 않는다. 그 이유는 파이썬은
stable`[22]`한 정렬을 하는데, 퀵정렬은 stable하지 않기 때문이다. 예를 들어 한글의 키값이 2, 숫자의 키값이 1이라 두면
1, ㄱ , ㄷ, ㄹ, 2를 퀵정렬해서 2, 1, ㄹ, ㄱ, ㄷ같은 게 나올 수도 있다. O(n)의 추가 메모리를 이용하면 stable한
퀵정렬을 만들 수 있다.  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%A0%95%EB%A0%AC?action=edit&sect
ion=6)]

#### 2.1.3. 그 밖에 ¶

  

  * 쉘 정렬(Shell's sort) 자르는 방식에 따라 다르다.  
  
버블정렬이나 삽입정렬의 경우 길이가 길어지면 하나 정렬하는데 한세월이 걸리는 경우도 있으므로 전체를
[적절히](%EC%A0%81%EC%A0%88.md) 잘라 정렬을 사용하고 정렬된 것끼리 합쳐서 정렬……을 반복한다. 이 때 [어떻게
자르느냐에 따라](http://en.wikipedia.org/wiki/Shellsort#Gap_sequences) 시간 복잡도도 제각각이다.
자르는 수를 잘 선택하는 경우 O(n1.25)`[23]`까지도 가능하다고 하는데 일반적인 데이터 크기에 모두 적용할 수 있는 것은 아니다.
알고리즘 자체가 쉽지 않고 퀵정렬이나 병합정렬에 비해 크게 나을 것이 없기에 일반적으로 쓰는 알고리즘은 아니다. 쉘 정렬이란 이름은 개발자인
[도널드 쉘](http://en.wikipedia.org/wiki/Donald_Shell)의 이름을 딴 것으로 유닉스의 쉘과는 관련이 없다.
이것을 잘 몰랐는지 예전 번역서에는 '껍질 정렬'로 [오역](%EC%98%A4%EC%97%AD.md)된 책이 있었다. 지금도 껍질 혹은
틀을 의미한다면서 큰 틀을 잡아나가면서 정렬해나가기에 셸 정렬이라는 말이 가끔 도는데 완전히 틀린 말이다.  

  * 기수정렬(Radix sort) O(n) - 수치적으로 n진수 배열을 할 수 있을 때만 사용가능한 고성능의 정렬.  
쉽게 말해 초등학교때 배웠을 법한 "자릿수가 많은수가 더 크고 자릿수가 같으면 앞자리가 큰 수가 크다."를 컴퓨터로 구현한 것`[24]`으로
n진수 배열이 불가능한 부동소수점 형식에는 쓸 수가 없다. n진법에서 각 자리수는 0~(n-1)의 n가지 이므로, 먼저 0~(n-1)까지를
분류할 저장공간을 할당하고 1의 자리수에 따라 **분류**해서 0에 있는 것들 꺼내고 1에 있는 것 꺼내고 ……(n-1)까지 한뒤, 이번에는
n의 자리수에 따라 실행 …… 반복한다. 가장 큰 수의 자릿수를 k라 두면 O(kn)정도 걸린다. 비교정렬이 아닌지라 O(n_lg_n)보다도
짧아질 수 있지만, 수의 크기에 따라서 작동 시간이 달라질 수 있다. "입력되는 수의 크기"에도 복잡도가 영향을 받는 알고리즘.  
  
예시) 10, 5, 15, 234, 1  
1의 자리수: (=0) 10, (=1) 1 , (=4) 234, (=5) 5,15  
10, 1, 234, 5, 15  
10의 자리수: (=0) 1, 5, (=1)10, 15, (=3) 234  
1, 5, 10, 15, 234  
102의 자리수: (=0)1, 5, 10, 15,(=2) 234  
1, 5, 10, 15, 234  

  * 카운팅정렬(Counting sort) O(n+k) - 카운팅정렬은 가장 큰 데이터에 따라 효율이 좌지우지된다.  
카운팅 정렬은 쉽게 설명하자면 특정 데이터의 개수(1이 두개있다면 2)를 데이터의 값에 대응하는 위치에 저장한 뒤, 자신의 위치에서 앞에
있던 값을 모두 더한 배열을 만든 뒤, 거기서 데이터가 들어가야할 위치를 찾아내는 정렬 알고리즘이다. 이 경우에 데이터의 최댓값을 k라
두면, 시간은 O(n+k). 하지만, 만약 k가 억단위를 넘어간다면?`[25]` n이 아무리 작아도 동작시간이 크다. 그럴 땐, 위의
정렬들을 사용하는 게 바람직하다. 반대로 k가 매우 작다면, 오히려 선형시간의 효과를 볼 수 있다. 즉, k가 작다는 조건이라면 매우
효율적인 정렬. 또한 카운팅 정렬은 배열을 사용하는 특성상, 정수라는 전제를 깔고 한다.  

그 방법은 아래와 같다.

  

  1. 자료를 탐색해서 그 최댓값을 구한다.  
데이터  
1 5 4 6 3 7 8 9 10 2  
최댓값  
k = 10

  2. k+1 만큼의 크기로 모든 자료가 0으로 초기화된 배열을 생성한다.  
배열 Counts  
0 1 2 3 4 5 6 7 8 9 10 - 배열 위치  
0 0 0 0 0 0 0 0 0 0 0

  3. 맨 처음 주어진 자료에 대응하는 곳에 +1을 해준다.  
0 1 1 1 1 1 1 1 1 1 1

  4. Counts i = Counts i + Counts i-1 의 점화식을 1부터 k의 위치까지 행한다.  
0 1 2 3 4 5 6 7 8 9 10

  5. ans라는 길이가 n인 배열을 생성한다.  
배열 ans (N = NULL)  
N N N N N N N N N N

  6. 맨 처음 주어진 자료에 대응하는 곳에 값의 -1 한 값에 대응하는 곳에 자료를 저장한다. 그리고, 맨 처음 주어진 자료에 대응하는 곳에 값은 -1 해준다.  
1이 주어짐  
대응하는 값이 1이니 0의 위치에 1을 삽입  
1 N N N N N N N N  
Counts의 값은 다음과 같이 바뀜  
0 1 2 3 4 5 6 7 8 9 10 => 0 0 2 3 4 5 6 7 8 9 10  
5가 주어짐  
대응하는 값이 5이니 4의 위치에 5를 삽입  
1 N N N 5 N N N N N  
Counts의 값은 다음과 같이 바뀜  
0 0 2 3 4 5 6 7 8 9 10 => 0 0 2 3 4 4 6 7 8 9 10  
...  
이런식으로 n개의 자료를 모두 조사하면 1 2 3 4 5 6 7 8 9 10 순서로 정렬이 된다.

  

  * 보고 정렬(Bogo sort, stupid sort) O(n!) - n개의 원소를 배열하는 가짓수는 n!이다. <del>이 설명이면 누군가는 눈치챘겠지</del>  
  
이름 그대로 멍청한 정렬이다. 랜덤으로 데이터들을 재배열 한 후, 정렬되었는지 검사한다(한 예로, 두 개의 원소를 고른 후 바꾼다). 정렬이
되어있지 않으면 다시 랜덤으로 재배열한다. 정렬될 때 까지 재배열한다. 덕분에 정렬된 데이터는 한방에 끝난다(...) <del>찍어서 모든
문제 맞추기</del> <del>구현 방법에 따라 **끝이 나지 않을** 수도 있다</del> <del>운이 좋으면 단박에
정렬된다</del>

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%A0%95%EB%A0%AC?action=edit&sect
ion=7)]

### 2.2. 참고 항목 ¶

  * [정렬/예제](%EC%A0%95%EB%A0%AC/%EC%98%88%EC%A0%9C.md)
  * [프로그래밍 언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md)
  * [자료구조](%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md)

`\----`

  * `[1]` 이쪽은 [안전행정부](%EC%95%88%EC%A0%84%ED%96%89%EC%A0%95%EB%B6%80.md)의 [행정구역코드](%ED%96%89%EC%A0%95%EA%B5%AC%EC%97%AD%EC%BD%94%EB%93%9C.md)를 우선적으로 사용한다.
  * `[2]` 전산학에서 [로그](%EB%A1%9C%EA%B7%B8.md)의 밑은 2인 경우가 많다. _log_2x를 _lg_x로 줄여서 쓴다.
  * `[3]` 스털링 근사 : lg(n!)≒n_lg_n-n로 유도 가능하다.
  * `[4]` 물론 중퇴후 명예학위라 결국 박사논문이 되지는 못했지만 그 정도 가치는 있었다고...
  * `[5]` 삽입 정렬은 자료의 정렬 상태에 따라 속도의 기복이 심하다. 실험에서는 값이 작은 것이 뒤로 몰려 있어서 삽입 정렬이 느리게 나타났던 것. 
  * `[6]` 물론 이것은 최악의 경우이다. 최상의 경우(이미 정렬된 경우)는 0번.
  * `[7]` ∑n-1(i=1) i = n(n-1)/2
  * `[8]`

![http://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_anim.
gif](http://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_an
im.gif)

[[GIF external image]](http://upload.wikimedia.org/wikipedia/commons/e/ef/Sort
ing_shaker_sort_anim.gif)

  * `[9]` 칵테일 정렬의 과정을 나타낸 그림
  * `[10]` 버블소트와 같은 O(n2)짜리 알고리즘은 데이터량에 비례해서 수행시간이 제곱으로 성장한다. 이게 뭐가 문제냐 할 수 있겠지만 만약 1억개의 데이터를 정렬한다고 치면 퀵정렬보다 무려 약 107=천만배 느리다.
  * `[11]` 엄청 최근 얘기처럼 들리지만 C++ STL은 90년대에 나왔다. 
  * `[12]` [C언어](C%EC%96%B8%EC%96%B4.md)의 의사코드를 제시한 [위키피디아](%EC%9C%84%ED%82%A4%ED%94%BC%EB%94%94%EC%95%84.md)의 문서를 그대로 복사해서 붙여넣었다.
  * `[13]` 최악의 경우가 n(n-1)/2에 비례다.
  * `[14]` 퀵정렬이나 병합정렬의 경우에는 재귀호출로 짜는 것이 편하므로 재귀호출로 만드는데, 힙정렬의 경우에는 함수호출 없이 만들 수도 있으므로 힙정렬이 가장 빠르다고 볼 수도 있다. 그리고 병합이나 힙정렬에 비해 퀵정렬은 메모리를 적게 사용하기 쉽다. 
  * `[15]` 그게 뭐가 중요하냐고 할 수 있지만, 실제 상황에서 여러 기준으로 정렬했을 때, 동일값에 대해선 기존 기준의 정렬순서가 유지되어야 한다. 예를 들어 동점일 경우 생년월일 기준으로 수상자를 뽑는 규정이 있는 대회에서 참가자들을 생년월일 순서대로 정렬해놓고 시험점수 기준으로 다시 정렬할 경우, 병합 정렬은 동점자들끼리 생년월일 순서대로 정렬된 것이 100% 유지된다.
  * `[16]` 단계별로 보는 힙정렬 알고리즘
  * `[17]` 표준 라이브러리 함수 qsort. 다만, 표준 규약에서는 알고리즘까지 명시하지는 않아서, 컴파일러 멋대로 실상은 버블 정렬을 쓰는 qsort를 만들 수도 있다. 이런 멍청한 짓을 상용 컴파일러에 할 제작자는 없겠지만.
  * `[18]` <del>느려터진</del> 의사난수를 이용할 수도 있으나 대개 중위법을 사용하는게 더 빠르다.
  * `[19]` 피벗을 첫번째 값으로 잡으면 한번 다 훑고(O(n)) 피벗을 **한칸** 옮기고 다시 비교하는 것을 n번해서 총 O(n2)가 된다. 피벗을 가운데로 정하면 O(n)을 n/2번 비교해서 총 O(n2/2)가 되는데 /2는 의미없으므로 (O2) 
  * `[20]` 이것도 정렬된 상태랑 마찬가지 방식으로 비교한다.
  * `[21]` [리눅스](%EB%A6%AC%EB%88%85%EC%8A%A4.md)에서 사용되는 glibc 라이브러리에 구현된 방법이 이것.
  * `[22]` 여러 원소의 키 값이 같을 경우 처음 데이터에서 앞서있는 원소가 정렬을 한 다음에도 앞서는 것
  * `[23]` 알고리즘 교과서에는 O(n1.33)의 예제가 있다.
  * `[24]` 다만 계산 방법상 뒷자리부터 맞춰간다.
  * `[25]` 데이터가 항상 작은값만 들어오리라는 보장이 없기 때문에 범용적으로 쓰기엔 문제가 있다. 또한 이 경우엔 메모리 효율성도 떨어진다. <del>만약 k가 21억이라면...</del> <del>8기가 메모리 : [버틸 수가 없다!](%EB%B2%84%ED%8B%B8%20%EC%88%98%EA%B0%80%20%EC%97%86%EB%8B%A4%21.md)</del>

