  * [BEMANI 시리즈](BEMANI%20%EC%8B%9C%EB%A6%AC%EC%A6%88.md)의 곡 중 재귀함수의 영어명칭을 가타가나로 적은 [リカーシブ・ファンクション](%E3%83%AA%E3%82%AB%E3%83%BC%E3%82%B7%E3%83%96%E3%83%BB%E3%83%95%E3%82%A1%E3%83%B3%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3.md)이라는 곡이 있다.  

再歸函數  
recursive function  
recursion(재귀)

어느 한 [컴퓨터공학과](%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99%EA%B3%BC.md)
학생이 유명한 교수님을 찾아가 물었다.  
"재귀함수가 뭔가요?"  
"잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어. 마을 사람들은 모두 그 선인에게 수많은 질문을 했고,
모두 지혜롭게 대답해 주었지. 그의 답은 대부분 옳았다고 하네.  
그런데 어느날, 그 선인에게 한 선비가 찾아와서 물었어.  
"재귀함수가 뭔가요?"  
["잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을...](%EB%A3%A8%ED%94%84%EB%AC%BC.md)

  

    
    
    (defun fibonacci-recursive (n)  (if (< n 2)      n     (+ (fibonacci-recursive (- n 2)) (fibonacci-recursive (- n 1)))))

[LISP](LISP.md) 으로 작성된 [피보나치수열](%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%20%EC%88%98%EC%97%B4.md)을 구하는
재귀함수. fibonacci-recursive 함수 내부에서 에서 자기 자신인 fibonacci-recursive에 n - 1, n - 2
를 인자로 넘겨서 다시 부르는 것을 볼 수 있다.

Prolog 로 작성된 Tail Recursion 형 [피보나치수열](%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%20%EC%88%98%EC%97%B4.md)을 구하는
재귀함수. 위의 예제와 다르게 함수의 인자를 결과를 저장하는 변수처럼 사용하는 것을 볼 수 있으며, fib(N, R2, R1, RF) 함수의
정의 끝에서 자기 자신을 다시 부르는 것을 볼 수 있다. 많은 선언형, 논리형, 함수형 언어는 이러한 Tail-Recursion 형태의
재귀함수를 최적화하는 기능을 가지고 있다.

  

하나의 [함수](%ED%95%A8%EC%88%98.md)에서 자신을 다시 호출하여 작업을 수행하는 방식으로 주어진 문제를 푸는
방법이다. 재귀 호출이나 되부름 이라고 불리기도 한다.

  

이 [링크](%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98.md)를 클릭하는 것은 재귀함수의 동작과
동일하다.`[1]`

  

수학에서는 recursive function 즉, 재귀함수라는것을 재귀를 포함함은 물론, 훨씬 더 광범위하게 정의하여 사용한다. 즉,
수학에서 모든종류의 알고리즘은 recursive function 으로 표현되며, 그렇기에 computable function 이란 용어도
사용한다. 루프문과 변수를 이용하는 반복적 알고리즘은 재귀함수로 표현할 수 있고 그 역도 성립한다. 이에 영향을 받아 등장한것이 바로
[LISP](LISP.md)와 같은 함수형 언어인데, 모든 프로그램(즉, 알고리즘)을 함수로 표현할 수 있다는것에 착안하여 만들어진
언어들이고, 이 언어들은 재귀를 밥먹듯이 사용한다`[2]`.

  

상술했듯 반복문으로 변수를 바꿔가는 형식의 명령형 계산은 항상 재귀적인 형식으로 똑같이 구현할 수 있으며 그 반대도 마찬가지지만, 현재
산업에서의 언어 패러다임은 대부분 명령형이기 때문에 대게 반복문으로 구현하는게 훨씬 익숙할 것이다. 무엇보다 함수는 호출될 때마다 그만큼
호출 스택 메모리를 잡아먹기 때문에 퍼포먼스 측면에서도 반복문이 낫다. 일반적인 명령형 언어([C](C.md),
[C++](C++.md), [Java](Java.md)). 다만 구현체에 꼬리재귀(Tail Recursion) 최적화가 되어있는
경우 꼬리재귀 요청이 스택에 걸리는 대신 이전 실행지점으로의 점프로 작동 하므로 실질적으로 루프문과 유의미한 성능 차이는 없게
된다.`[3]` 꼬리재귀 최적화의 경우 함수형 언어 구현체에는 필수적으로 들어가며, 명령형 언어 컴파일러에도 구현되어 있는 경우가 있다.
C, C++의 경우 [GCC](GCC.md), clang/llvm, VC 등의 주요 컴파일러에는 다 구현 되어 있기 때문에 안심하고
사용해도 된다.

  

명령형 언어에서도 재귀가 필요할 때가 있는데, 반복문으로 구현했다가는 코드가 심하게 복잡해지거나, 프로그래머가 만들다가 로직이 꼬여
[안드로메다](%EC%95%88%EB%93%9C%EB%A1%9C%EB%A9%94%EB%8B%A4.md)로 가는 상황이 발생하는 문제들도
있기 때문. 이 경우 재귀함수로 구현하는 것이 간단하고 훨씬 더 이해하기 쉬운 경우가 있다. 예를 들어 XML이나 JSON을 파싱한다거나
[QuickSort](%EC%A0%95%EB%A0%AC#s-2.1.2.md)를 만든다면 반복문보다 재귀를 쓰는 것이 더 쉽다. 이런
경우 생 루프문으로 처리하려면
[스택](%EC%8A%A4%ED%83%9D%28%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%29.md)을
구현해야한다.

  

하지만 대부분의 명령어 언어 구현체에서는 간단한 재귀함수를 몇 줄 차이뿐인 반복문으로 쓰는 것이 더 좋은 관계로`[4]` 절차적 언어에서의
재귀를 써야하는 경우는 매우 적다. 더불어 명령어 언어 사용자들이 재귀를 꺼리게 되는 추가적인 이유는 이게 반복을 하는 놈인지 아닌지 알기
어렵다는 점에 있다. 반복문이 대놓고 문장 한가운데서 '이 블록은 반복될 것임'하고 알려주는 것과 다르게 재귀는 별다른 표시없이 혼자
돌게되므로 코드 내에서 가독성이 떨어지게 된다. 추가적으로, 흐름을 추적하기 어렵다는 이유도 한몫한다.<del>머리에 호출 스택을 심어놓은
사람이 아니면야..</del>

  

반면에 함수형 언어로 가면 상황은 180도 달라지는데, 함수형 언어 스타일 상에선 루프문이 없을 뿐더러 애초에 필요성도 별로 못 느낀다.
설령 언어에 루프가 있더라도 재귀적으로 구현했다간 코드가 심하게 복잡해지거나
[안드로메다](%EC%95%88%EB%93%9C%EB%A1%9C%EB%A9%94%EB%8B%A4.md)로 가는 <del>이거 어디서
많이 본 문장인데</del> 특수한 상황이 아니면 거의 안쓴다. `[5]`

  

상황이 이렇다보니 간단한 연산부터 일관되게 재귀로만 짜는 함수형 언어에 대한 절차적 언어 사용자들의 반응은 [충격과공포](%EC%B6%A9%EA%B2%A9%EA%B3%BC%20%EA%B3%B5%ED%8F%AC.md) 그 자체. 더구나 함수형 언어
사용자는 변수 및 for-loop보다 재귀호출로 이루어진 것이 버그가 적고 가독성도 좋고(!) 로직이 훨씬 명확하다고 느낀다(!!). 오히려
재귀호출이 너무 당연한 개념이라 명령형 언어에서 재귀호출을 멀리하는 것을 이해하지 못한다.

  

이렇게 되는 이유 중의 하나는 프로그래밍을 생각하는 방식의 차이 때문이다. 명령형 언어에서 '상태와 그 상태의 변화의 반복'에 집중한다면,
함수형 언어에서는 '어떤 인자에 대응되는 값'이라는 관계, 즉 함수를 생각한다.  
명령형 개념에서 재귀호출은 '자기 자신을 호출한다'라는 흐름 제어로 인식하는 반면, 함수형 패러다임에 익숙한 사람은 재귀호출은 마치
점화식처럼 자기 함수와의 값의 관계를 맺는 것이라고 생각한다.

  

이런 생각은 상태 변화를 생각하는 것과는 달리 관계 그 자체에 치중하여 코딩할 수 있게 한다. 또한, 이런 생각을 도와주는 게 함수형
언어에서 부수효과가 없다는 건데... 자세한 건 [함수형 언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4#s-4.4.1.md)참조. 아니면 [LISP](LISP.md)나 OCaml 등의
함수형 언어를 공부하면서 뇌 개조(..)를 당해보면 된다.

  

[알고리즘](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md) 시간에 가끔 재귀 관계적 사고 방식을 길러주려고
일부러 반복문 포함된 알고리즘을 재귀식으로 변환하라는 문제가 나오기도 한다.

  

[프로그래밍언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md)를
배울 때 수학에서 재귀적으로 정의되어 반복문보다 가독성 좋게 재귀함수로 옮길 수 있는
[팩토리얼](%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC.md), [하노이의탑](%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98%20%ED%83%91.md)이나 [피보나치수열](%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%20%EC%88%98%EC%97%B4.md)등을 재귀함수로
구현하는 과제가 종종 출제된다. 다만 재귀함수를 아직 잘 이해하지 못한 [뉴비](%EB%89%B4%EB%B9%84.md)들이 구현하면
99.9% 무한루프에 빠진다(…). 재귀 함수의 무한루프에서 벗어나고 싶으면 함수를 종료할 조건을 넣어 줘야 한다. 참고로 필수다. 명령형
언어에서 퍼포먼스 측면에서 안 쓰는 게 좋다고 가르치는 것 중 하나가 이 재귀함수지만 재귀로 만들면 편할 때가 있어서 쓰게 된다는 게
문제점이 있다. 그러나 스택 깊이 이상을 뚫어버리는 경우가 아니면 의도적인 알러지 반응을 일으킬 필요는 없다. 오히려 의미상 더 명료하다면
사실 써도 별 상관없다. 실제로 STL 알고리즘 구현체도 내부적으로 재귀호출을 쓰는 경우가 많다.

`\----`

  * `[1]` 링크 오류가 아니다! 구글도 비슷한 예를 들고 있다. recursion 으로 검색해보자. 구글의 센스를 엿볼 수 있다.
  * `[2]` 보통 ML계열 같은 하이브리드 함수형 언어가 아니면 반복문 자체가 없거나, 있더라도 재귀로 구현되어 있다.
  * `[3]` 물론 구현체에 꼬리재귀 최적화가 없거나 재귀함수가 꼬리재귀할 수 없다면, 루프문이 **무조건** 빠르다.
  * `[4]` 주요 구현체중 꼬리재귀 최적화가 없는 경우가 많기 때문이다. 대표적으로 JVM은 꼬리재귀 최적화가 없다.
  * `[5]` 그도 그럴 것이 루프문은 돌면서 변수를 변화시키고 루프가 끝나면 변화된 값을 얻어내는 목적이 있다. 그런데 함수형 언어에서는 일반적으로 변수가 없고 '정의'만이 있을 뿐이다. 물론 [하스켈](%ED%95%98%EC%8A%A4%EC%BC%88.md)같은 순수 함수형 언어가 아니면 변수 비슷한 것을 만들 수는 있지만 언어 구조상 조금 부자연스럽다.

