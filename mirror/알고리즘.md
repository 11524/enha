  * [컴퓨터 관련 정보](%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4.md)  

algorism / algorithm(알고리듬)  
가끔 알고리즘의 "알고"를 [한국어](%ED%95%9C%EA%B5%AD%EC%96%B4.md)의 "알다"로 아는 사람도 있다.
<del>알고이씀</del>

## Contents

    

1. 통상적인 의미 
2. 알고리즘의 조건 
3. 알고리즘의 표현 방법 
4. 알고리즘의 평가 
5. 일상 생활에 쉽게 사용하는 알고리즘들 
    

5.1. 미로 찾기

5.2. [루빅스 큐브](%EB%A3%A8%EB%B9%85%EC%8A%A4%20%ED%81%90%EB%B8%8C.md) 풀기

5.3. 마방진

6. 프로그래밍에서 사용하는 알고리즘들 

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=1)]

## 1. 통상적인 의미 ¶

문제를 해결하기 위한 절차나 방법. <del>[이런거](http://francomics.egloos.com/2013816)</del>

  

이 단어는 [아랍](%EC%95%84%EB%9E%8D.md)의 수학자인 알-콰리즈미(الخوارزمي)의 이름에서 유래했다고 알려졌다.
영어로는 algorism보다는 algorithm(알고리듬)으로 훨씬 더 자주 쓰지만 한국에서는 알고리듬보다는 알고리즘의 사용 빈도가
높다.`[1]`

  

알고리즘이라는 용어는 **문제를 해결하기 위한 절차나 방법**을 의미하는 단어로 넒은 범위에서 사용된다. 조금 더 정확한 의미를 따져보자면
알고리즘은 어떠한 행동을 하기 위해서 만들어진 명령어들의 유한 집합(finite set)이다.  
컴퓨터 프로그램은 정교한 알고리즘들의 집합이라고 간주할 수 있다. 수학이나 컴퓨터 과학에서 말하는 알고리즘은, 보통 반복되는 문제를 풀기
위한 작은 프로시저를 의미한다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=2)]

## 2. 알고리즘의 조건 ¶

알고리즘은 이하의 요건을 만족해야만 한다.  

  * 입력 - 알고리즘은 0 또는 그 이상의 외부에서 제공된 자료가 존재한다.
  * 출력 - 알고리즘은 최소 1개 이상의 결과를 가진다.
  * 명확성 - 알고리즘의 각 단계는 명확하여 애매함이 없어야 한다.`[2]`
  * 유한성 - 알고리즘은 단계들을 유한한 횟수로 거친 후 문제가 해결되고 종료되어야 한다. 알고리즘의 한 단계 이후 m의 값은 n 보다 작으며, m!=0이면 n의 값은 다음 번 단계에서 줄어든다.
  * 효과성 - 알고리즘의 모든 연산들은 사람이 종이와 연필을 이용하여 유한한 시간 안에 정확하게 수행할 수 있을 정도로 충분히 단순해야 한다.  

즉, 쉽게 말하면 알고리즘은 어떠한 입력이 있다면 이 입력에 따라 명령을 명확하게 실행하고 효과적으로 입력에 따른 결과물을 도출 할 수
있다면 알고리즘으로 볼 수 있다는 의미이다. 반대로 명령에 애매함이 있다거나 유한한 시간 안에 끝나는 것이 보장되지 않은 경우를
[메서드](%EB%A9%94%EC%84%9C%EB%93%9C.md)(Method)라고 한다. 예를 들어 '산에서 길을 잃었을때 계곡을
찾아서 아래로 내려간 뒤 물길을 따라 하류로 가면 된다.' 라는 문장은 메서드이다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=3)]

## 3. 알고리즘의 표현 방법 ¶

알고리즘은 크게 3개의 표현 방법을 가진다. 첫번째는 고차원적인 언어로 인간이 이해하기 쉬운 말로 설명되어 있는 형태이며`[3]`, 두번째는
구현 상세 내역이며, 마지막으로는 인간이 꽤 알아먹기 힘든 [튜링머신](%ED%8A%9C%EB%A7%81%20%EB%A8%B8%EC%8B%A0.md)의 Stable Table이라고 불리는 그림이나
출력물의 형태로 나타내는 방법이 있다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=4)]

## 4. 알고리즘의 평가 ¶

알고리즘이 위의 조건들을 모두 만족한다면 문제를 풀 수 있다고 할 수 있지만, '효과적으로' 풀어낸다고 할 수는 없다. 위에서 말한 유한한
시간이 몇 달 혹은 몇 년이 될 수도 있기 때문이다. 따라서 우리는 알고리즘을 효율성으로 평가하게 되고, 컴퓨터에서는 시간과 메모리라는 두
자원을 얼마나 소모하는지가 효율성의 중점이 된다.

  

  * 시간 복잡도(time complexity)
알고리즘의 소요시간을 정확히 평가할 수는 없으므로, 자료의 수 n이 증가할 때 시간이 증가하는 대략적인 패턴을 시간 복잡도라는 이름으로
나타내게 된다.`[4]`, 예를 들어서 O(n)의 시간복잡도를 가진 알고리즘은 대략 (상수)*n 번의 연산을 수행한다고 보면 된다.

  

보통 O(n)의 알고리즘은 최상의 결과이고`[5]`, log(n)의 지수승이 붙는 정도로 막으면(O(n log(n)) 등) 매우 바람직한
결과이다. O(n^3) 정도만 되도 큰 자료수에선 급격히 느려진다.  
이런 식으로 시간복잡도가 n의 다항식 이하가 되는 알고리즘들을 다항 시간 알고리즘(polynomial time algorithm)이라고
한다. 여기까지만 보면 다항식과는 [넘사벽](%EB%84%98%EC%82%AC%EB%B2%BD.md)`[6]`의 증가속도를 자랑하는
O(2n ) 또는 O(n!) 같은 알고리즘은 매우 막장인 것처럼 보이지만, 세상에는 이 따위 알고리즘밖에 [방법이없는](%EB%8B%B5%EC%9D%B4%20%EC%97%86%EB%8B%A4.md) 어려운 문제들이 수두룩하다. 더 자세한 이야기는
[P-NP 문제](P-NP%20%EB%AC%B8%EC%A0%9C.md) 참고.

  

  * 공간 복잡도(space complexity)
현실에서는 시간복잡도보다 중요도는 떨어지는데, 시간이 적으면서 메모리까지 지수적으로 증가하는 경우는 없기 때문이고, 다항시간 내에서 나타나는
메모리 문제들은 보통 알고리즘 자체보다는 알고리즘의 구현에서 발생하는 문제이기 때문이다. 다만 이론적으로는 n에 대한 다항식만큼의 공간으로도
해결이 안되는 정말 어려운 문제들`[7]` 을 생각하기도 한다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=5)]

## 5. 일상 생활에 쉽게 사용하는 알고리즘들 ¶

<del>그러니까 이제 딱딱한 이야기는 버리고</del> 현실적으로 쓸모있는 알고리즘은 생각외로 많다. <del>예를들면 **[파인만 알고리즘](%ED%8C%8C%EC%9D%B8%EB%A7%8C%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md)**
이라던지</del>

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=6)]

### 5.1. 미로 찾기 ¶

[우선법](%EC%9A%B0%EC%84%A0%EB%B2%95.md)이나 좌선법이 미로를 찾는 알고리즘 중 하나다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=7)]

### 5.2. [루빅스 큐브](%EB%A3%A8%EB%B9%85%EC%8A%A4%20%ED%81%90%EB%B8%8C.md) 풀기 ¶

[큐브의해법](%EB%A3%A8%EB%B9%85%EC%8A%A4%20%ED%81%90%EB%B8%8C/%ED%95%B4%EB%B2%95.md)
참고.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=8)]

### 5.3. 마방진 ¶

홀수 마방진의 경우 대각선으로 숫자를 써가면서 다 채운 다음에 상하좌우에 튀어나온 숫자들을 반대편으로 넘기면 끝난다. [뿌리깊은나무](%EB%BF%8C%EB%A6%AC%EA%B9%8A%EC%9D%80%20%EB%82%98%EB%AC%B4.md)에서 어린 세종이
이걸 스스로 찾아내는 장면이 나온다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%9
8?action=edit&section=9)]

## 6. 프로그래밍에서 사용하는 알고리즘들 ¶

<del>다시 딱딱한 이야기로</del>  

  * 자료구조: [정렬](%EC%A0%95%EB%A0%AC.md), 탐색, 각종 트리(tree)와 힙(heap)
  * 알고리즘 패러다임: [DFS](DFS.md), [백트래킹](%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9.md), [다이나믹 프로그래밍](%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md)
  * 그래프 알고리즘: 탐색, 최단 거리 찾기, 네트워크 흐름(network flow) 알고리즘
  * 기타 KMP 등의 문자열 매칭, Pollard's rho 등의 정수론 알고리즘, 해석기하/그래픽 알고리즘 등등.  

더 관심있는 위키러는 이 중 <del>크고 아름다운</del> [정렬](%EC%A0%95%EB%A0%AC.md) 항목을 반드시 읽어보길
바란다.

`\----`

  * `[1]` 2012년 10월 16일 [구글](%EA%B5%AC%EA%B8%80.md) '다음 단어 또는 문구 정확하게 포함' 검색 결과: "algorithm" 124,000,000건, "algorism" 760,000건, "알고리듬" 290,000건, "알고리즘" 4,510,000건
  * `[2]` 이 조건에 의해 [난수](%EB%82%9C%EC%88%98.md)가 알고리즘에 포함되지 않을 것 같으나, 컴퓨터에서의 난수는 이전 결과를 이용하는 의사 난수이기 때문에 알고리즘에 포함된다.
  * `[3]` [의사코드](%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C.md)(pseudocode)가 이 범주에 들어간다
  * `[4]` 자세한 asymptotic이나 O-표기법의 이론은 생략한다.
  * `[5]` 대부분의 경우 자료를 읽는 데에 어쨌든 n의 시간이 필요하므로. 물론 검색알고리즘에서 O(n)은 최악.
  * `[6]` 굳이 표현하자면 n < n log n << n2 <<< n3 <<<< n4 <<<<<< (넘사벽) <<<<< 2n <<<<<<<<<<<<< (넘사벽) <<<<<<<<<<<<<<<<<<< n! 정도가 되지 않을까.
  * `[7]` 앞에 넘사벽처럼 어렵다고 한 문제들 이상의 우주급 넘사벽이 있다!

