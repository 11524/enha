## Contents

    

1. Compiler 
2. [아사미야 키아](%EC%95%84%EC%82%AC%EB%AF%B8%EC%95%BC%20%ED%82%A4%EC%95%84.md)의 만화 

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%A
C?action=edit&section=1)]

## 1. Compiler ¶

  * [컴퓨터 관련 정보](%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4.md)  

어떤 [프로그래밍언어](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4.md)로
쓰여진 소스 파일을 다른 언어로 바꾸어주는 번역 프로그램. 대부분 고수준 언어를
[기계어](%EA%B8%B0%EA%B3%84%EC%96%B4.md)로 번역하는 프로그램을 일컫지만 엄밀히는 어떤 언어 A를 B로 바꾸면
그게 컴파일러다. [Scheme](Scheme.md)을 C언어로 번역한다든지, 심지어 기계어를
[C언어](C%EC%96%B8%EC%96%B4.md)로 번역하더라도(!) 컴파일러라고 칭할 수 있다. `[1]`

  

초기엔 어떤 프로그램을 작성하기 위해서는 컴퓨터 위에서 바로 돌아가는
[기계어](%EA%B8%B0%EA%B3%84%EC%96%B4.md)를 통하여
[프로그래밍](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.md)을 했다. 그러나 이런 과정은
생산성, 기기 간 호환성`[2]`, 디버깅 등 모든 면에서 효율적이지 않기 때문에 컴퓨터 공학의 발전과 더불어 많은 부분이 추상화된 고수준
언어를 작성하고 이를 [번역기](%EB%B2%88%EC%97%AD%EA%B8%B0.md)를 통해 기계어로 번역하기 시작했는데, 이
번역기가 바로 컴파일러이다. 현재 많은 [프로그램](%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.md)은
[컴파일러](%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC.md)를 통하여 전체를 기계어로 번역하여 실행하므로
프로그램 개발에 필수적인 툴 중에 하나다.

  

반면에 소스를 한꺼번에 번역하지 않고 명령 하나하나를 실행할 때마다 해석하여 계산하는 방법도 있는데 이 해석기를
[인터프리터](%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0.md)라 해서 따로 분류한다.
컴파일러가 번역기라면 인터프리터는 통역기인셈.

  

재밌는 것은 컴파일러도 결국 하나의 언어로 짜여진 프로그램이라는 점. 따라서 원리상
[C언어](C%EC%96%B8%EC%96%B4.md) 프로그램이 [C언어](C%EC%96%B8%EC%96%B4.md)를 번역하는
일이 가능하다. 이 경우, C 컴파일러를 사용하기 위하여 이 컴파일러를 컴파일하는데 C 컴파일러가 필요하다(..) 심지어 최근 버전의
[gcc](gcc.md) 컴파일러의 경우 [C++](C++.md)을 사용하기 때문에 C 컴파일러를 컴파일하는데 C++ 컴파일러가
필요하다. 이런 현상을 부트스트래핑(bootstrapping)이라고 한다. 언어를 최초 설계할 때만 사용 가능한 다른 언어로 짜여진
컴파일러의 도움을 받은 이후로는 언어를 번역하는 컴파일러가 자기 자신의 언어로 짜여질 수 있다. 얼핏보면 모순적이지만 맨 처음에만 다른
언어의 도움을 받는다면 충분히 가능하다. 일반적으로 고수준 언어로 갈수록 생산성이 높아지므로 이런 접근은 컴파일러를 작성하는데 들이는 비용을
효과적으로 줄일 수 있다. 일례로, GHC라는 [Haskell](Haskell.md) 컴파일러는 최초에 Lazy ML이라는 다른 언어로
작성되었다가, 자기 자신의 언어인 [Haskell](Haskell.md)로 재작성 되었다.  

원칙적으로 컴파일러는 프로그램을 기계어로 바꾸기만 할 뿐 이를 바로 실행이 가능하게 하지는 않는다. 여러 소스 파일에서 나온 결과물을 합치고
라이브러리도 포함시키는 등 별도의 작업을 거쳐야 실행이 가능해지는데 이를 수행하는 프로그램이 링커이다. 하지만 보통은 그냥 뭉뚱그려
컴파일러라 부르는 경우가 많다. 또한 요즘은 그냥 프로그램 하나만 돌리면 컴파일과 링킹을 한 번에 끝낼 수 있게 되어 있다. 물론
내부적으로는 컴파일러와 링커가 따로 있어서 이를 이용하는 경우가 많지만.

  

[어셈블리어](%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4.md)를 번역하는 프로그램은 컴파일러라
하지 않고 따로 [어셈블러](%EC%96%B4%EC%85%88%EB%B8%94%EB%9F%AC.md)라 한다.

  

요즘 컴파일러들은 기계가 프로그램을 빠르게 돌릴 수 있도록 적절한 최적화 작업을 하고 프로그래머가 실수할만한 부분을 경고하는 등 갈수록
똑똑해지는 추세이다.

  

C 등의 고급 언어에서 CPU의 인스트럭션 하나로 해결할 수 있는 복잡한 기능(?)을 사용할 경우 특정 함수를 호출하면 컴파일러가 함수를
호출하는 명령을 넣어 주는 것이 아니라 그냥 그 자리에 어셈블리를 사용한 것과 동일하게 기계어 코드를 때려박는 경우가 있는데 이것을
intrinsic, 혹은 built-in function이라고 한다(인라인 함수와는 다르다). Compare-And-Exchange의 예를
들어(현대적인 CPU는 대부분 지원한다) a값이 m인 경우 n으로 바꾸는 코드의 경우 x86 CPU는 cmpxchg 인스트럭션 하나로 해결이
가능하다. 즉 C로 작성하는 것보다 어셈블리가 더 간단한데(?) 이러한 경우 컴파일러가 지원하는 인트린식을 사용하면 된다.

  

    
    
    int a, b;...b = CAS(&a, 10, 20);....

  

  * C 코드
  

    
    
    int CAS(int* pos, int oldval, int newval){    int oldpos = *pos;    if(*pos == oldval)        *pos = newval;    return oldpos;}

  

  * 어셈블리 코드(x86-64)
  

    
    
    CAS:    movl        %edx, %eax    lock    cmpxchgl    %esi, (%rdi)    ret

  

  * VC++ intrinsic
  

    
    
    b = _InterlockedExchange(&a, 20, 10);

  

  * gcc built-in function
  

    
    
    b = __sync_val_compare_and_swap(&a, 10, 20);

<del>참 쉽죠?</del>

  

[인텔](%EC%9D%B8%ED%85%94.md)의 x86 CPU는
[삼각함수](%EC%82%BC%EA%B0%81%ED%95%A8%EC%88%98.md)나
[로그](%EB%A1%9C%EA%B7%B8.md) 등의 실수연산을 CPU가 바로 지원해주기 때문에 x86용 컴파일러는 대부분의 수학
함수를 인트린식으로 지원한다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%A
C?action=edit&section=2)]

## 2. [아사미야키아](%EC%95%84%EC%82%AC%EB%AF%B8%EC%95%BC%20%ED%82%A4%EC%95%84.md)의 만화 ¶

**[만화 및 애니메이션 관련 정보/일본](%EB%A7%8C%ED%99%94%20%EB%B0%8F%20%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8.md)**

[ㄱ](%EB%A7%8C%ED%99%94%20%EB%B0%8F%20%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%84%B1.md)

[ㄴ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%84%B4.md)

[ㄷ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%84%B7.md)

[ㄹ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%84%B9.md)

[ㅁ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%81.md)

[ㅂ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%82.md)

[ㅅ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%85.md)

[ㅇ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%87.md)

[ㅈ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%88.md)

[ㅊ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%8A.md)

[ㅋ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%8B.md)

[ㅌ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%8C.md)

[ㅍ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%8D.md)

[ㅎ](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%E3%85%8E.md)

[숫자](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%EC%88%AB%EC%9E%90.md)

[알파벳](%EB%A7%8C%ED%99%94%26%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4/%EC%9D%BC%EB%B3%B8/%EC%95%8C%ED%8C%8C%EB%B2%B3.md)

  

전뇌(컴퓨터)세계에서 날아온 컴파일러, 어셈블러, 인터프리터 등의 루틴이라는 존재들의 여성들을 중심으로 한 코미디 만화. 연애 노선도, 개그
노선도, 스토리성도 애매한 작품이었다. 속편으로는 연애 노선이 약간 늘어난 어셈블러OX 가 있다. 주인공인 컴파일러는 작가가 그린 또 다른
작품인 사일런트 메비우스 0에 잠시 등장하기도 했고 현재 연재중인 히메가미 가젯에도 등장한다.`[3]`

  

뮤직 클립 영상과 [OVA](OVA.md)도 만들어졌다.음의 장과 양의 장,그리고 컴파일러 파스타 총 3종.

  

음의 장은 개그 요소가 전혀 없는 진지한 일상,양의 장은 개그&연애요소 라는 상반된 분위기가 특징. 파스타는 본편 처럼 정신 없는 분위기.

  

`\----`

  * `[1]` 이 경우 [기계어](%EA%B8%B0%EA%B3%84%EC%96%B4.md)를 대상 언어로 번역하는 컴파일러와의 구분을 위하여, 각각 전자를 트랜스컴파일러(transcompiler)나 소스간 컴파일러(source-to-source compiler), 후자를 디컴파일러(decompiler)라고 많이 부른다.
  * `[2]` 예를 들어서 [ARM](ARM.md) 아키텍쳐 대상으로 작성된 프로그램은 [x86](x86.md) 아키텍쳐에서 안돌아가는 식으로. 
  * `[3]` 히메가미 가젯 5편 말미에 컴파일러가 등장한다.

