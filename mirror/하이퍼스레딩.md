[인텔](%EC%9D%B8%ED%85%94.md)의 CPU 기술 중 하나.

요즘 CPU는 파이프라이닝이라 해서 CPU 전체가 한 번에 하나의 명령을 처리하는 것이 아니라 명령 하나를 CPU의 각 부분이 나눠서 처리할
수 있는 여러 단계의 작은 명령으로 나누고 각 부분을 차례대로 처리한다. 즉 명령이 몇분의 1로 나누어지고, 그런 명령 몇 개가 한번에
돌아가는 것이다.

이런 식으로 작동하는 이유는 많은 기계어 명령이 코드로는 하나로 되어 있어도 실제 처리해야 하는 일은 여러 단계로 나누어져 있고 각 단계는
이전 단계가 처리되기 전에는 수행이 불가능하기 때문이다. 예를 들어 메모리의 값을 증가시키는 명령이  

> 1 메모리의 값을 읽는다.  
2 읽은 값을 더한다.  
3 값을 메모리에 쓴다.

와 같이 작동한다면 [1번이 끝나기 전에는 2번을 할 수 없고 2번이 끝나기 전에는 3번을 할 수 없다](%ED%95%9C%20%EB%B2%88%EC%97%90%20%ED%95%9C%20%EB%86%88%20%EB%B2%95%EC%B9%99.md).

그런데 실제로는 명령이 처리되기 위해 필요한 일이 명령마다 다르다. CPU의 예시는 아니지만, 네트워크 비동기 처리의 예시를 들어보자.
네트워크에서 특정 값을 읽어 이를 처리하는 경우, 상당한 경우에는 네트워크의 대기시간이 프로그램 전체 실행시간의 대부분을 차지한다. 이
상황에서 위와 같이  

> 1 네트워크의 값을 읽는다.  
2 읽은 값을 처리한다.  
3 값을 저장장치에 쓴다.

로 코드를 작성한다면, 1번의 네트워크 대기 지연 시간에 의해 프로그램은 상당히 비효율적인 구조를 가지게 될 것이다. 1번이 느리게
작동된다면, 2~3번을 하는 도중에 1번을 미리 가져오면 될 것이 아닌가?  
이와 비슷하게 어떤 명령을 처리하느냐에 따라 CPU의 일부분은 놀게 된다.

하이퍼스레딩은 이런 놀고 있는 부분에 다른 명령의 일부를 투입하여 CPU의 효율을 높이려는 것이다.

논리적으로는(즉 S/W의 관점으로는) 하나의 코어에 하나의 가상의 코어를 만들어서 CPU 2개로 인식된다. 기본적으로 별개의 명령을 처리해야
하기 때문. 그래서 HT가 지원되는 CPU를 [작업관리자](%EC%9E%91%EC%97%85%20%EA%B4%80%EB%A6%AC%EC%9E%90.md)에서 보면 코어 수가 2배로
뻥튀기되는 것을 알 수 있다.

물론 진짜 CPU 2개보다는 성능이 떨어진다. 이 논리로 하이퍼스레딩이 있어봤자 느려터졌다고 하지만, 그래도 단일 코어 환경에 비하면
[멀티태스킹](%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9.md) 환경에서 한 프로세스가 많은
연산을 할 경우 상대적으로 다른 프로세스에 훨씬 많은 여유를 줄 수 있는 장점이 있다. 예를 들어 3D 렌더링을 할 경우 진가가 드러나는데,
3D 렌더러는 스레드당 한 개의 렌더링 블록을 생성해 내는데, 하이퍼스레딩이 켜진 쿼드코어 CPU의 경우 8개의 스레드가 생성되어(즉
논리적인 옥타코어) 시간의 이점을 볼 수 있다. (20% 정도 차이가 난다)

예를 들어 1과 2라는 프로세스(스레드)에서 명령을 처리할 때  
(<int>는 다른 프로세스로 전환)

하이퍼 스레딩이 없는 CPU 의 경우,  
1  
1  
1  
1 <int>  
2  
2  
2 <int>  
1  
1 <int>  
2 <end>  
1 <end>

이런식으로 한번에 하나의 명령만 처리 할 수 있다.

하이퍼 스레딩이 있을 경우엔,

1  
1,(2)  
1  
1,(2)  
1  
1,(2)  
1 <end>  
2  
2  
2 <end>  
(* (2): 2의 일부)

이런 식으로 처리할 내용을 우겨넣어서 성능의 향상을 꾀하는 기술이다.

[Pentium 4](%EC%9D%B8%ED%85%94%20%ED%8E%9C%ED%8B%B0%EC%97%844%20%EC%8B%9C%EB%A6%AC%EC%A6%88.md) Northwood에서 처음 사용되었다.`[1]` 특히 [WindowsXP](Windows%20XP.md)에만 지원을 하는 바람에 윈도우즈 XP의 보급률을 크게 상승시켜준 일등공신이지만, 그놈의 넷버스트
아키텍처 때문에(…) 효율은 그다지 좋지 못했다. 당시 별명은 **하이퍼쓰레기**(…) 이후 [인텔 펜티엄D 시리즈](%EC%9D%B8%ED%85%94%20%ED%8E%9C%ED%8B%B0%EC%97%84D%20%EC%8B%9C%EB%A6%AC%EC%A6%88.md)에서
잘렸다가 [인텔 아톰 시리즈](%EC%9D%B8%ED%85%94%20%EC%95%84%ED%86%B0%20%EC%8B%9C%EB%A6%AC%EC%A6%88.md)에서 다시 부활하였고`[2]`, 이후 [인텔 코어 i 시리즈](%EC%9D%B8%ED%85%94%20%EC%BD%94%EC%96%B4%20i%20%EC%8B%9C%EB%A6%AC%EC%A6%88.md)에서도 등장했다. 여기서는 **쿼드코어 i5를
제외한 모든 제품군**에 지원되고 있다. 성능 자체는 많이 나아졌다. 비록 논리코어지만 과거의 오명을 벗을 만큼 가시적인 성능향상이 있다.
<del>괜히 트렌지스터 더 때려박는게 아니다</del> 특히 4코어 지원 게임에서, 2코어 4스레드인 i3와 2코어 2스레드인 펜티엄 간의
대결은 i3가 확실히 앞선다. i3 4130과 g3258 4.5ghz 오버클럭 버전의 경우에, 멀티코어 지원 게임에서 g3258이 더 낮은
클럭의 i3에게 지는 것을 볼 수 있다.

다만, 펜티엄 4이든 코어 i시리즈든 하이퍼스레딩을 켜면 **발열과 전력소모가 증가한다**.`[3]` 풀로드 시 많게는 3~40w가량 더
소모하므로 주의할 것.

`\----`

  * `[1]` 단, 전 제품 모두 지원하는 것은 아니고, B시리즈 최상급 코어(3.06GHZ)와 C시리즈 코어만 가능하다. 그 이하는 지원 불가.
  * `[2]` 현재 [넷북](%EB%84%B7%EB%B6%81.md),[넷탑](%EB%84%B7%ED%83%91.md)에 탑재된 아톰의 거의 대부분이 지원한다. Z500/Z510 같은 초 저전력 프로세서는 전력 문제로 빼는 경우도 있으니 이는 각자 검색바람.
  * `[3]` 위의 설명처럼 같은 시간에 더 많은 명령을 처리하므로 개념은 다르지만 [오버클럭](%EC%98%A4%EB%B2%84%ED%81%B4%EB%9F%AD.md)과 비슷한 원리인 셈.

