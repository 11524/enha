  * [동음이의어](%EB%8F%99%EC%9D%8C%EC%9D%B4%EC%9D%98%EC%96%B4.md), [수학 관련 정보](%EC%88%98%ED%95%99%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4.md)  

## Contents

    

1. 상대적으로 적은 수 
2. 1보다 작은 단위에서 유의미한 값을 가지는 수 
3. 1과 자신만을 약수로 갖는 수 
    

3.1. 소수와 알고리즘, 암호

    

3.1.1. 소수판정법 및 소인수분해

3.2. 소수의 일반화

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%86%8C%EC%88%98?action=edit&sect
ion=1)]

## 1. 상대적으로 적은 수 ¶

少數

  

상대적으로 적은 수. 반댓말은 다수

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%86%8C%EC%88%98?action=edit&sect
ion=2)]

## 2. 1보다 작은 단위에서 유의미한 값을 가지는 수 ¶

小數  
Decimal <del>floating point를 생각했다면 좋은
[코딩덕후](%EC%BD%94%EB%94%A9%EB%8D%95%ED%9B%84.md)</del>

  

xxxx.xxxxx... 로 나가는 수.

  

자릿수가 유한한 유한소수와 자릿수가 무한히 계속 이어지는 무한소수가 있다. 소숫점 아래가 주기적으로 반복되면 순환소수, 그렇지 않으면
비순환소수라 한다. [무리수](%EB%AC%B4%EB%A6%AC%EC%88%98.md)는 늘 비순환소수이며,
[유리수](%EC%9C%A0%EB%A6%AC%EC%88%98.md)는 (기약분수꼴로 나타냈을 때의) 분모에 따라 유한한 소수표현을
갖거나 순환소수이다.

  

규칙이 있지만 **대수적인 방법으로 구할 수 없는 수**는 [무리수](%EB%AC%B4%EB%A6%AC%EC%88%98.md)이면서
그중에서도 [초월수](%EC%B4%88%EC%9B%94%EC%88%98.md)에 해당한다. 예를 들어서,
0.12345678910111213...같이 1씩 커진다는 규칙이 있지만.. 이 숫자를 만들 식이 없으니
[망했어요](%EB%A7%9D%ED%96%88%EC%96%B4%EC%9A%94.md).

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%86%8C%EC%88%98?action=edit&sect
ion=3)]

## 3. 1과 자신만을 약수로 갖는 수 ¶

素數  
Prime Number  
<del>[만악의근원](%EB%A7%8C%EC%95%85%EC%9D%98%20%EA%B7%BC%EC%9B%90.md)</del>`[1]`  
<del>[범 우주적인 언어라고 한다](%EC%BD%98%ED%83%9D%ED%8A%B8.md)</del>

  

예전에는 ‘솟수’라고 표현했으나 맞춤법을 고치면서 ‘소수’로 바뀌었고, 그 덕분에 위의 항목들과 혼동되지 않도록 유의해서 써야 한다. 발음은
바로 위의 항목과 구분하러 계속 ‘소쑤’라고 하는 편. 북한의 [문화어](%EB%AC%B8%ED%99%94%EC%96%B4.md)로는
‘씨수’라고 하며, 한국에서도 용어를 ‘씨수’로 바꾸자고 주장하는 수학자들이 있다.

  

소수의 정의는 ‘1보다 큰 자연수 중에 1과 자신으로밖에 나누어 떨어지지 않는 수’이다.`[2]` 1보다 큰 자연수 중에 소수가 아닌 수는
합성수(composite number)라고 한다. 쉽게 이해하기 위해 소수를 ‘[약수](%EC%95%BD%EC%88%98.md)가
2개뿐인 수’로 정의하기도 한다. 참고로 1은 소수도, 합성수도 아니다. 처음 몇 개의 소수들을 나열하면 다음과 같다.

  

[2](2.md), [3](3.md), [5](5.md), [7](7.md), [11](11.md),
[13](13.md), [17](17.md), [19](19.md), [23](23.md),
[29](29.md), [31](31.md), [37](37.md), [41](41.md),
[43](43.md), [47](47.md), [53](53.md), [59](59.md),
[61](61.md), [67](67.md), [71](71.md), [73](73.md),
[79](79.md), [83](83.md), [89](89.md), [97](97.md),
[101](101.md), [103](103.md), [107](107.md), [109](109.md),
[113](113.md)...

  

위 나열에선 알기 힘들지만 수가 커질수록 소수들의 빈도는 점점 감소하며, 소수가 없는 아주 긴 구간들의 출현 빈도들이 높아진다. 이쯤 되면
결국 나중엔 소수가 절대 나오지 않게되는 게 아닌가 하는 추측도 나올 수 있겠지만,
[유클리드](%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C.md)에 의해 **소수는 무한히 많이 있다**는 것이
증명되었다. [오일러](%EC%98%A4%EC%9D%BC%EB%9F%AC.md)도 다른 방식으로 증명하였다.  
유클리드는 다음 명제를 증명함으로써 소수의 무한성을 증명했다. “_p_1, _p_2, … _p__n_이 소수이면, 이들 모두와는 다른 소수가
항상 존재한다.”증명은 다음과 같다. “_p_1, _p_2, … _p__n_ 모두의 공배수 _N_을 하나 찾고(예를 들어 위 소수를 몽땅
곱한 것) _N_+1을 생각한다. 이는 _p_1, _p_2, … _p__n_의 어느 것으로도 나누어 떨어지지 않으므로 새로운 소인수 _p_를
갖는다.” 따라서 소수는 유한 개가 아니고 무한
개이다.[#](http://navercast.naver.com/contents.nhn?rid=22&contents_id=304) 이처럼
유클리드의 증명은 귀류법이 아니며, 일반적으로 널리 알려진 귀류법을 이용한 증명은 유클리드의 아이디어만 빌렸다고 하는 편이
정확하다.`[3]`

  

2 이상의 모든 자연수는 한 개 이상의 소수들의 곱으로 유일하게 나타낼 수 있고, 이 유일한 표현을 소인수분해라 한다. 어찌보면 당연해
보이면서도 흥미로운 사실인데, 소수들의 성질만 연구해도 모든 정수의 성질을 알 수 있다는 의미이기 때문. 덕분에 소수는 자연수와 정수의
성질을 연구하는 [정수론](%EC%A0%95%EC%88%98%EB%A1%A0.md)의 중심 탐구대상이었다.

  

하지만 소수의 성질을 밝히는 것은 생각보다 매우 어렵다. 많은 수학자들이 위 무한한 소수들의 분포나 규칙성을 밝혀내려고 했지만, 어느 누구도
정답이라고 할 패턴을 밝혀내진 못했다. 현재까지도 소수에 관련된 다음처럼 많은 문제들이 남아서 호기심을 자극한다.  

  * [골드바흐의 추측](%EA%B3%A8%EB%93%9C%EB%B0%94%ED%9D%90%EC%9D%98%20%EC%B6%94%EC%B8%A1.md): 4 이상의 임의의 짝수가 두 소수 합으로 나타내 질 수 있는지
  * 쌍둥이 소수 문제: 차이가 2인 소수들의 쌍이 무한히 많은지 아닌지
  * [메르센 소수](%EB%A9%94%EB%A5%B4%EC%84%BC%20%EC%86%8C%EC%88%98.md) 문제: 2^(소수) - 1 꼴의 소수가 무한히 많은지 아닌지
  * [페르마](%ED%8E%98%EB%A5%B4%EB%A7%88.md) 소수 문제: 2^2^n + 1 꼴의 소수가 무한히 많은지 아닌지.
비록 수학의 미해결제가 많기는 하지만, 문제는 소수와 관련된 **이런 대부분의** 문제들이 미해결이라는 것이다...

  

현대수학자들은 소수의 분포에 대해서 순수하게 무작위적이라는 가설을 세우고 있다. 소수의 개수는 특정 평균선을 기준으로 변동하는데, 그
변동하는 양에서는 주기성 같은 경향을 더 찾을 수가 없다는 이야기. 어떤 의미에서 이는 **소수의 쉬운 패턴을 찾기란 불가능함**을
암시한다. 물론 이런 이야기를 하는 수학자 자신들은, 이 믿음의 기초인 [리만가설](%EB%A6%AC%EB%A7%8C%20%EA%B0%80%EC%84%A4.md)에서조차 리만이 예견한 수준을 아직도 벗어나지
못하고 있다.<del>도대체 이사람들은 뭘 제대로 알지?</del>

  

왠지 일본 서브컬처물에서, 극도의 긴장이나 당황한 상태에서 "침착하자, 침착하게 마음을 안정시키고 소수를 세는거다."라는 혼잣말을 하면서
진정을 하는 묘사가 나오는데. 이는 [죠죠의 기묘한 모험](%EC%A3%A0%EC%A3%A0%EC%9D%98%20%EA%B8%B0%EB%AC%98%ED%95%9C%20%EB%AA%A8%ED%97%98.md)에서 나온 것, 죠죠 6부 [스톤오션](%EC%8A%A4%ED%86%A4%20%EC%98%A4%EC%85%98.md)의 등장인물인 [엔리코푸치](%EC%97%94%EB%A6%AC%EC%BD%94%20%ED%91%B8%EC%B9%98.md)의 버릇에서 유래된 것. 항목
참고.

  

일본에서 '모든 소수의 곱은 홀수인가 짝수인가?'가 논란이 된 적 있다. 얼핏 보면 짝수인 [2](2.md)가 들어있어서 짝수일 것
같지만... 모든 소수를 곱한 것은 수가 아닌 발산하는 극한으로 홀수, 짝수 여부를 확인할 수 없다. 참고로 [재규격화를 이용해 구한 모든
소수의 곱은 4π^2^라고
한다.(???)(PDF)](http://cds.cern.ch/record/630829/files/sis-2003-264.pdf) 이건 비슷한
예를 들자면 무한등비급수 1 + x + x2 \+ x3 \+ ... = 1/(1-x)는 원래는 -1<x<1에서만 성립하는데, 이 제약을
풀어서 1 + 2 + 4 + 8 + ... = -1이라고 하는 것과 비슷하다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%86%8C%EC%88%98?action=edit&sect
ion=4)]

### 3.1. 소수와 알고리즘, 암호 ¶

소수의 문제는 전통적으로 순수수학의 영역에 속했지만, 20세기 후반 암호학과 컴퓨터의 발전으로 현실과 밀접한 관련을 맺는다.

  

암호학에서는 이른바 일방향함수(one-way function)를 필요로 한다. 일방향함수란 컴퓨터과학에서 쓰이는 용어로, 임의의
입력값으로부터 출력값을 계산하는 것은 쉽지만, 특정 출력값에 해당하는 입력값을 찾는 것은 어려운 함수를 말한다. 쉽게 말해 연산은 쉬운데
역연산은 어려운 것이다(이때 ‘쉽다’, ‘어렵다’는 계산복잡도를 의미한다). 두 수를 곱하는 것은 엄청 쉽지만, 소인수분해는 대표적인 어려운
문제에 속하기 때문에 이를 일방향함수로서 이용할 수 있다.`[4]`

  

소인수분해가 어렵다는 점을 이용하는 암호체계로 [RSA](RSA#s-2.md)(2번 항목) 암호체계가 있다. 이 암호체계는 아주 큰
소수 _p_와 _q_의 곱 _pq_를 이용해 암호화를 하지만, 비밀키를 모르는 제3자가 암호를 가로채 해독하려면 _p_와 _q_ 자체가
필요하다(고 알려져 있다).`[5]` 그러나 예를 들어 다섯 자리 숫자 둘을 곱하는 건 손으로도 금방 하지만, _pq_ =
1459160519를 알려주고 소인수분해하여 34853, 42193을 찾으라고 한다면…… 상당히 어려울 것이다. 실제로 RSA에 쓰이는
소수는 [10진법](10%EC%A7%84%EB%B2%95.md)으로 몇백 자리의 소수들이다.

  

덕분에 이런 아주 큰 소수를 찾고 그 수가 소수인지 아닌지를 정하는 소수판정법과, 역시 큰 수를 소인수분해하는 알고리즘이 중요한 이슈로
떠올랐다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%86%8C%EC%88%98?action=edit&sect
ion=5)]

#### 3.1.1. 소수판정법 및 소인수분해 ¶

어떤 수가 소수임을 판정하려면 어렵다. 가장 간단하게 생각할 수 있는 방법은, 2부터 제곱근n까지의 소수로 모두 나누어 보는
것이다.`[6]` 하지만 n이 50여자리만 되어도 나눗셈을 몇 번 해야 되는지는 상상만 해도 끔찍하다.

  

1부터 n까지 모든 소수를 찾는 방법으로 고대 그리스의 수학자 [에라토스테네스](%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4.md)가 만들어 낸 방법이 있는데, 이는 하나의 수가 소수인지 아닌지를 판정하는
것보다는, 일정 범위 내의 소수를 모두 찾아내는 데 이용하는 경우가 많다. 이 방법은 마치 체로 치듯이 수를 걸러낸다고 하여
'[에라토스테네스의 체](%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%20%EC%B2%B4.md)'라고 부른다. 과정은 아래와 같다.  

  1. 2부터 시작해서 찾아내고 싶은 범위만큼 자연수를 죽 늘어 놓는다.
  2. 먼저 2를 소수로 표시하고 2를 제외한 2의 배수(4, 6, 8, 10, ...)를 모두 소거한다.
  3. 그 다음 3을 소수로 표시하고 남아있는 수 중 3을 제외한 3의 배수(9, 15, 21, ...)도 모두 소거한다.
  4. 그 다음 수인 4는 2의 배수라서 소거되었으므로 건너뛴다.
  5. 그 다음 수인 5를 소수로 표시하고 남아있는 수 중 5를 제외한 5의 배수(25, 35, 55, ...)도 모두 소거한다.
  6. 이 과정을 계속 반복한다.
이렇게 하다 보면 어느 정도까지 왔을 때`[7]` 소수만 남는다. 아래 그림은 에라토스테네스의 체로 1에서 100까지의 수 중 소수를 찾아낸
예이다.  

![Erathosthenes_sieve.PNG](//rv.wkcdn.net/http://rigvedawiki.net/r1/pds/Eratho
sthenes_sieve.PNG)

[PNG image (9.24 KB)]

  
이 그림에서 굵은 수는 소수를 의미한다. 색깔을 입힌 것은 진행 과정을 알 수 있게 하기 위한 것이다.  
물론 모든 소수를 찾는다면 사실상 이 방법 뿐이지만, 하나의 소수만을 찾는다면 이건 위에서 말한 제곱근n 나눗셈보다도 훨씬 느리니 당연히
꽝이다.

  

이산수학과 알고리즘이 발전하면서 소수판정법은 비약적으로 발전하였다. 1976년 발명된 밀러-라빈 판정법은 매우 빠른 시간 (대략
log(n)의 세제곱) 내에 소수를 판별할 수 있지만, 무작위 방법을 쓴다. 밀러-라빈 판정법의 원리는 간단히 말하자면 페르마의 소정리를
많은 경우에 만족시키는지 아닌지를 보는 것이다. 페르마의 소정리는 n이 소수일 때 만족하는 식을 주므로, 이 판정을 통과하지 못했다면 바로
n이 합성수임을 알 수 있다. 하지만 어떤 합성수 n이 여러 번의 판정을 우연히 통과할 확률은 시행횟수 k에 따라서 1/4k 이하로 현격하게
줄어드니(실제로는 이보다 더욱 작다), 이 확률을 무시한다면 실용적으로는 "k번 판정을 통과했으니 소수일 것이다"라고 할 수 있다. 물론 이
[어떤 확률](%EC%96%B4%EB%96%A4%20%ED%99%95%EB%A5%A0.md) 급의 확률에 재수없게 걸려 합성수를
소수라고 판별할 가능성도 있지만.

  

2006년에 인도의 세 학생 Manindra Agrawal, Neeraj Kayal, Nitin Saxena이 결정론적 방법을 쓰는 AKS
알고리즘을 개발함으로서, _이론적으로_ 소수판정이 log(n)의 다항 시간안에 풀릴 수 있음을, 즉 P-문제임을 보였다. [P-NP문제](P-NP%20%EB%AC%B8%EC%A0%9C.md) 참고. 물론 실용적으로는 훨씬 빠른 밀러-라빈 등을 선호한다.

  

한편 소인수분해의 문제는 소수판정과는 다르게, 매우 어렵다. 확률적 해법으로 양보하더라도 log(n)의 다항시간 등으로 나온다는 것은 아직
상상도 할 수 없다. 이 문제가 어려워 어찌 보면 다행인데, 이 문제가 쉽다면 소수기반 암호체계의 대부분이 모두 무용지물이라서다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EC%86%8C%EC%88%98?action=edit&sect
ion=6)]

### 3.2. 소수의 일반화 ¶

소수의 일반화로 **기약수**가 있다.  
앞서 자연수 영역에서의 소수를 ‘1보다 큰 자연수 중에 1과 자신으로밖에 나누어 떨어지지 않는 수’로 정의하였으나, 사실은 다음 두 정의가
혼용되고 있었다.  

  * _p_>1이고 _ab_=_p_이면 _a_=1 또는 _b_=1.
  * _p_>1이고 _p_|_ab_이면 _p_|_a_ 또는 _p_|_b_.  
(_a_|_b_는 _a_가 _b_로 나누어 떨어진다는 뜻.)  

이 두 정의는 자연수의 소인수분해를 생각하면 동치임이 명백하다. 그러나 다항식에서 비슷한 역할을 하는 기약다항식 등을 연구하면서, 수학자들은
두 정의가 일반적으로는 동치가 아님을 알게 되었다. 따라서 다음과 같이 구분하게 되었다.

  

_R_이 1을 갖는 [가환환](%ED%99%98#s-4.md)일 때, _p_∈_R_에 대하여  

  * _p_가 non-zero, non-unit이고 `[`_a_,_b_∈_R_에 대해 _ab_=_p_이면 _a_∈_R_× 또는 _b_∈_R_×`]`이면 _p_는 **기약수(irreducible element)**.
  * _p_가 non-zero, non-unit이고 `[`_a_,_b_∈_R_에 대해 _p_|_ab_이면 _p_|_a_ 또는 _p_|_b_`]`이면 _p_는 **소수(prime element)**.  

정역(Integral domain)에서는 모든 소수는 기약수이다.`[8]` 그러나 그 역은 일반적으로는 참이 아니며, 유일 인수분해
정역(Unique factorization domain)에서는 모든 기약수는 소수임을 증명할 수 있다.

  

소수의 또 다른 일반화로 소 아이디얼(prime ideal)이 있다. _R_이 1을 갖는 가환환일 때, _R_의
[아이디얼(ideal)](%EC%95%84%EC%9D%B4%EB%94%94%EC%96%BC%28ideal%29.md) _I_에 대하여
_I_≠_R_이고 `[`_a_,_b_∈_R_에 대해 _ab_∈_I_이면 _a_∈_I_ 또는 _b_∈_I_`]`이면 _I_는 **소
아이디얼**이라 한다. 약수와 배수 관계가 아이디얼의 포함관계에 대응된다는 점을 생각하면 위 정의가 소수에 관한 앞서의 정의와 상통함을 알
수 있다. 따라서 **_p_≠0일 때** _p_가 소수인 것과 _p_가 생성하는 아이디얼 (_p_)이 소 아이디얼인 것이 동치임은 자명하다.

  

주의할 점은 _R_ 자신은 소 아이디얼이라고 부르지 않는다는 것이다. 이는 1이 소수가 아닌 것과 마찬가지이다. 즉, 소 아이디얼의 정의에서
_I_≠_R_이라는 조건은 _p_가 non-unit이라는 조건에 대응된다. 그러나 또 주의할 점은 _I_가 non-zero일 것은 요하지
않으므로, 영 아이디얼 0도 소 아이디얼일 수 있다는 것이다. 따라서 앞서의 명제에서 _p_≠0이라는 조건을 빼먹으면 곤란하다.

  

`\----`

  * `[1]` 수올을 한 적이 있는 위키러라면 누구나 공감할 것이다.
  * `[2]` 그래서 소수는 **[2](2.md)를 제외하면 모두 [홀수](%ED%99%80%EC%88%98.md)이다.** 모든 [짝수](%EC%A7%9D%EC%88%98.md)가 2로 나누어 떨어지기 때문.
  * `[3]` 귀류법 버전은 다음과 같다. “소수가 유한 개(_n_개)라고 가정하면 _p_1, _p_2, … _p__n_과 같이 모두 나열할 수 있다. 이제 이 소수들을 몽땅 곱한 뒤 1을 더한 수 _P_ = _p_1_p_2…_p__n_+1을 생각한다. 이 _P_는 위 _p_1, _p_2, … _p__n_의 어느 수로도 나누어 떨어지지 않는다. 따라서 _P_는 위 나열된 소수 외의 새로운 소인수 _p_를 가지고, 이는 소수가 _n_개라는 데 모순이다.”  
참고로 위 마지막 문장을 “따라서 _P_는 새로운 소수이고, 이는 소수가 _n_개라는 데 모순이다.”라고 바꾸어도 **전혀 틀린 것이
아니다.** 왜냐하면, _P_가 1과 자신 외의 약수를 가진다면 그 약수를 나누는 소인수를 가져야 하는데 _p_1, _p_2, …
_p__n_ 어느 것도 _P_의 소인수가 아니기 때문이다. 따라서 _P_는 1과 자신 외의 약수를 갖지 않고, 따라서 (위 귀류법의 가정
하에서) _P_가 소수라고 하는 데 아무런 장애도 없다.  
이렇게 설명을 해도 이해하지 못하고 실제로 소수 몇 개를 곱해서 1을 더한 뒤 합성수가 되는 경우를 찾아 반례랍시고 들이미는 사람들이
있는데, 그건 반례가 되지 않는다. 귀류법에서는 소수를 **모두** 곱한 뒤 1을 더한 것이지 소수를 **몇 개만** 곱한 것이 아니기
때문이다. 가정이 다른데 어떻게 반례가 되는가? 그 설명은 귀류법 버전이 아닌 원래 유클리드의 증명에 대한 설명으로서 의미가 있는 것이다.
네이버 캐스트에서도 “그 **(귀류법)** 증명을 보고 오해하는 사람이 적지 않아 지나가는 길에 언급해 두고 싶다. **(유클리드 버전)**
증명에 나온 N+1이 기존의 소수로 나눠 떨어지지 않으므로, 그 자체가 소수여야 한다고 생각하는 것이 가장 흔한 오해에 속한다.”라고 말한
것이고 아래에서 유클리드 버전에 대해 설명을 한 것이다. 분명히 해 두는데, 귀류법 버전에서는 _P_가 소수라고 해도 아무 문제 없고, 다만
유클리드 버전에서는 _N_+1이 소수라고 생각하면 큰일나는 것이다.

  * `[4]` 공개열쇠 방식은 공개열쇠와 비밀열쇠를 구분한다는 것이 본질이고, 일방향함수와 직접적인 관련은 없다.
  * `[5]` 정확히 말하면 _p_와 _q_를 알면 비밀키를 쉽게 알아낼 수 있다는 뜻이다. _p_와 _q_를 모르고도 비밀키를 알아낼 수 있는 쉬운 방법이 있는지는 미해결 문제이다.
  * `[6]` n이 합성수라면 제곱근n 이하의 소인수가 있다고 쉽게 알 수 있다.
  * `[7]` 4번 각주를 이용하면 n보다 작은 자연수 중에 소수만 남기는데는 제곱근 n이하의 수까지만 해보면 된다는걸 알 수 있다.
  * `[8]` 증명: _ab_=_p_이면 _p_|_ab_이다. 예를 들어 _p_|_a_라 하면 어떤 _c_∈_R_에 대해 _pc_=_a_이고, 첫 식에 대입하여 _pcb_ = _ab_ = _p_를 얻는다. 양변에서 _p_를 소거하면 _cb_ = 1이므로 _b_∈_R_×.

