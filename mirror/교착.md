## Contents

    

1. 원 의미 
2. [테니스](%ED%85%8C%EB%8B%88%EC%8A%A4.md) 용어 
3. [컴퓨터](%EC%BB%B4%ED%93%A8%ED%84%B0.md) 용어 
    

3.1. 예시를 동반한 <del>머리 깨지는</del> 설명

4. 기타 

![deadlock.jpg](//rv.wkcdn.net/http://rigvedawiki.net/r1/pds/_ea_b5_90_ec_b0_a
9/deadlock.jpg)

[JPG image (225.77 KB)]

  
대충 이런 상황

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B5%90%EC%B0%A9?action=edit&sect
ion=1)]

## 1. 원 의미 ¶

A와 B가 협상을 하는데 A가 요구하는 것을 B는 거부하고, B가 요구하는 것을 A가 거부하여 협상의 진전이 전혀 없는, 협상이 완전히
답보된 상태를 말한다. 양자 간의 예가 대표적인 예일 뿐이지, 실제로는 다자간의 협상에서도 얼마든지 교착 상태가 일어날 수 있다.(예) A의
요구를 B,C가 거부, B의 요구를 C,D가 거부, C의 요구를 A,D가 거부, D의 요구를 A,B가 거부) 특히 이 상태가 지속되는 경우
협상 지연 등으로 협상의 주체 모두가 피해를 볼 수 있다. [패자뿐인싸움](%ED%8C%A8%EC%9E%90%EB%BF%90%EC%9D%B8%20%EC%8B%B8%EC%9B%80.md) 내지
[병림픽](%EB%B3%91%EB%A6%BC%ED%94%BD.md)이 될 가능성이 농후하다는 것. 이를 평화적으로 해결하는 유일한
방법은 서로가 양보하는 것 뿐이다. 한쪽이 일방적으로 밀리는 방법도 방법은 될 수 있지만, 이 경우 후유증이 심할 수 있는지라 비추.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B5%90%EC%B0%A9?action=edit&sect
ion=2)]

## 2. [테니스](%ED%85%8C%EB%8B%88%EC%8A%A4.md) 용어 ¶

테니스에서 듀스(Deuce) 상태가 지속되어 승부를 판가름하기 어려운 상태.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B5%90%EC%B0%A9?action=edit&sect
ion=3)]

## 3. [컴퓨터](%EC%BB%B4%ED%93%A8%ED%84%B0.md) 용어 ¶

Deadlock. 혹은 교착 상태.

  

[운영체제](%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.md) 혹은
[소프트웨어](%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4.md)의 잘못된
[자원](%EC%9E%90%EC%9B%90.md) 관리로 인해서 둘 이상의 프로그램(심하면 **운영체제 자체**도 포함해서)이 같이
[다운](%EB%8B%A4%EC%9A%B4.md)돼버리는 현상을 말한다. 아래에서 설명하겠지만, 잘 이해하지 못하겠다면 그냥 프로그램
내지는 스레드 둘이서 자원 한 개를 놓고 협상하다가 1의 교착 상태에 빠졌구나 하고 이해하면 쉽다.

  

발전된 [현대](%ED%98%84%EB%8C%80.md)의 운영체제는 당연하게도 프로그램 미숙으로 인해 교착이 일어날 가능성을 어느
정도는 염두에 두고 있다. 해서, OS는 교차점에서 자원을 놓고 교착 상태에 빠지는 것을 가능하면 회피시켜버린다. 하지만 아무리 예측을 잘
하고 회피를 잘 해도 결국 답이 안 보이는 놈은 있는 법. 언젠가는 교착 상태에 빠져버리는 경우가 생길 수 있다. 이런 경우에는 프로그램
자체를 강제로 종료해버리는 수밖에 없는데, 교착에 빠진 프로그램 목록에 저놈들을 관리해야 할 **운영체제가 끼어 있다면** 그냥
망해버리는거다. 이런 일이 발생하기 쉬운 경우가 시스템 파일이나 다른 프로그램이 공유하는 파일을 건드리기 쉬운 프로그램 설치 과정인데,
"프로그램을 설치할 때는 가능하면 다른 프로그램은 모두 꺼 주세요"라는 말이 나오는 이유가 이 놈 때문이다.

  

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B5%90%EC%B0%A9?action=edit&sect
ion=4)]

### 3.1. 예시를 동반한 <del>머리 깨지는</del> 설명 ¶

왜 이런 현상이 일어나는지 알아보려면 일단 멀티스레딩이 기본적으로 어떻게 돌아가는 것인지 알 필요가 있다. 가장 원시적인 멀티스레딩 방식으로
생각할 수 있는 것은, 단순히 함수 두 개 이상의 흐름을 운영체제가
[적절하게](%EA%B9%80%EB%8C%80%EA%B8%B0.md) 연결해 가면서`[1]` 돌리는 것이다.

  

하지만 이렇게 [멀티태스킹](%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9.md)을 처리해버리면
서로 같은 자리의 데이터를 읽거나 써야 할 때 문제가 발생한다. 예를 들어 "(초기 상태에서는 0인) 변수 A에 1을 더한다."라는 작업을
스레드를 두 개로 나눠서 천만 번 수행한다고 가정하자. 이론상 이러면 A는 이천만이 되어야 할 것 같지만 실제로는 그렇지 않다! 얼핏 보면
문제가 없어 보이는 이 코드를 돌려보면 [로또](%EB%A1%9C%EB%98%90.md)가 터지지 않는 한 이천만보다 모자란 값이
나온다. 그 이유라면, 사실 이 작업은 아래와 같이 쪼개져서 이뤄지기 때문이다.  

  * A의 메모리 주소에 있는 값을 레지스터`[2]`로 불러온다.
  * 레지스터에 불러온 값에 1을 더한다.
  * 1을 더한 값을 다시 메모리에 쓴다.
...그리고 저 작업들이 줄 단위로 쪼개질 수 있다는데서 문제가 생겨버린다. 설명의 편의를 위해 천만 번씩 수행하는 것을 한 번으로 줄여서
다시 해보자. 가끔씩 아래와 같은 상황이 나올 수 있다.`[3]`  

  * 첫 번째 스레드는 A의 메모리 주소에 있는 값을 레지스터로 뽑아온다.(A는 0이었다.)
  * 두 번째 스레드는 A의 메모리 주소에 있는 값을 레지스터로 뽑아온다.(A는 **0**이었다.)
  * 첫 번째 스레드는 불러온 값에 1을 더한다.(0에다가 1을 더하니 1.)
  * 두 번째 스레드는 불러온 값에 1을 더한다.(0에다가 1을 더하니 1.)
  * 첫 번째 스레드는 불러온 값을 다시 메모리에 쓴다.(A는 1이 된다.)
  * 두 번째 스레드는 불러온 값을 다시 메모리에 쓴다.(A는 **1이 된다!**)
결과적으로 **2가 되어야 할 A는 1이 된다.**

  

이런 현상을 막기 위해 막기 위해 세마포어`[4]`나 뮤텍스`[5]`가 도입이 된다. 저건 간단히 말해서 어떤
[플래그](%ED%94%8C%EB%9E%98%EA%B7%B8.md)가 서 있는 동안에는 특정한 변수는 건드리지 않는다는 것이다. 쉽게
말해 뮤텍스의 각주에 나온 것과 같이 [자물쇠](%EC%9E%90%EB%AC%BC%EC%87%A0.md)를 채우는 거다. 예를 들어,
다음과 같이 코드를 수정한다고 하자.  

  * Lock이라는 뮤텍스가 올라가 있는지 확인하고, 안 올라가 있으면 올린다. 올라가 있으면 내려올 때까지 기다린다.
  * (중략...)
  * Lock을 내린다.
다시 방금의 예로 돌아가자.  

  * 첫 번째 스레드는 일단 Lock이 올라가 있는지 확인한다. 당연히 처음이니까 내려가 있다. 즉시 Lock을 올린다.
  * 두 번째 스레드는 일단 Lock이 올라가 있는지 확인한다. Lock은 이미 올라가 있으니 세월아 네월아 기다린다.
  * 두 번째 스레드가 아무 것도 못 하고 있으니, 첫 번째 스레드는 문제 없이 A의 메모리 주소에 있는 값을 레지스터로 뽑아오고, 불러온 값에 1을 더하고, 다시 메모리에 쓴다. A는 1이 된다.
  * 첫 번째 스레드가 Lock을 내린다.
  * 두 번째 스레드는 Lock이 내려간 것을 확인. A를 뽑아오고(1이다), 불러온 값에 2를 더하고(2가 된다), 다시 메모리에 쓴다. A는 2가 된다.
이것은 첫 번째 스레드와 두 번째 스레드의 순서를 바꿔도 제대로 작동하는 예제가 된다. 그렇다면 이걸로 끝일까? 끝이면 이 항목이 있을
리가. 이번에는, 스레드 두 개가 서로 다른 코드를 돌리고 있는 경우를 생각해보자. 첫 번째 스레드는 다음과 같이 동작한다.  

  * Lock1이라는 뮤텍스가 올라가 있는지 확인하고, 안 올라가 있으면 올린다. 올라가 있으면 내려올 때까지 기다린다.
  * Lock2라는 뮤텍스가([이하생략](%EC%9D%B4%ED%95%98%EC%83%9D%EB%9E%B5.md))
  * A에 1을 더한다.
  * Lock2를 내린다.
  * Lock1을 내린다.
두 번째 스레드는 다음과 같이 동작한다.  

  * Lock2라는 뮤텍스가(이하생략)
  * Lock1이라는 뮤텍스가(이하생략)
  * A에 1을 더한다.
  * Lock2를 내린다.
  * Lock1을 내린다.
이렇게 두 개의 스레드를 돌린다면, 재수없으면 이런 꼴이 나버린다.  

  * 첫 번째 스레드가 Lock1을 확인한다. 내려가 있으니 올린다.
  * 두 번째 스레드가 Lock2를 확인한다. 내려가 있으니 올린다.
  * 첫 번째 스레드가 Lock2를 확인한다. 안 내려가 있으니 기다린다.
  * 두 번째 스레드가 Lock1을 확인한다. 안 내려가 있으니 기다린다.
첫 번째 스레드는 두 번째 스레드가 Lock2를 풀어줘야 동작할 수 있다. 그런데 두 번째 스레드는 첫 번째 스레드가 Lock1을 풀어줘야
동작할 수 있다.

  

**[......어?](%EB%A7%9D%ED%96%88%EC%96%B4%EC%9A%94.md)**

  

이런식으로 스레드 두 개의 요구사항이 서로 1번의 교착 상태에 빠져버려서, **프로그램은 기약 없는 기다림 속에 [무한루프](%EB%AC%B4%ED%95%9C%20%EB%A3%A8%ED%94%84.md)에 빠진다.**

  

물론 현실은 항상 이렇지만은 않다. 위 예제는 교착 상태를 의도적으로 일으키기 위해 극단화한 경우이고, 실제로는 예상하지 못한 곳에서 코딩
미스나 운영체제의 설계 미스, 혹은 스펙 한계 등의 이유로 의도하지 않은 교착 상태가 발생할 수 있다는 것. 여러 개의 스레드가 얽히고 여러
종류의 락을 사용할 경우 훨씬 더 복잡하고 골치아픈 경우가 많다. 그래프 알고리즘을 이용하여 교착 상태를 검출해낼 수 있으나 n개의 락을
이용할 경우 O(n3)의 알고리즘이 되어 상당한 성능 저하를 일으킨다.

  
  

  

위 동영상 9:44초에 데드락에 대한 동영상 설명이 나온다.

[[edit](http://rigvedawiki.net/r1/wiki.php/%EA%B5%90%EC%B0%A9?action=edit&sect
ion=5)]

## 4. 기타 ¶

[리플렉 비트](%EB%A6%AC%ED%94%8C%EB%A0%89%20%EB%B9%84%ED%8A%B8.md)의 수록곡은
[DEADLOCK](DEADLOCK.md) 참조.

`\----`

  * `[1]` 완전히 설명하려면 레지스터의 백업이나 스택, 가상 메모리 같은 컴공과 들어가야 배우는 단어가 나오니까 "적절하게"라는 단어로 여기서는 넘어가도록 한다.
  * `[2]` CPU가 직접 연산을 할 수 있는 공간이라 생각하면 편하다.
  * `[3]` 역시 편의상 스레드 사이의 넘겨주기는 생략한다. 사실 스레드 전환에도 작업이 필요하기 때문에 한 줄 단위로 번갈아가면서 실행하는 경우는 거의 없다. 하지만 중간에 스레드를 전환할 수 있는 한 값은 언제든지 어긋날 수 있다.
  * `[4]` Semaphore, 원래 뜻은 "수기 신호"
  * `[5]` Mutex, **Mut**ual-**ex**clusion lock 즉 상호 배제 잠금이라는 뜻

