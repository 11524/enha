  * [컴퓨터 관련 정보](%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B4%80%EB%A0%A8%20%EC%A0%95%EB%B3%B4.md) \- [인코딩](%EC%9D%B8%EC%BD%94%EB%94%A9.md)  

**[한글](%ED%95%9C%EA%B8%80.md)의 [전산화](%EC%BB%B4%ED%93%A8%ED%84%B0.md) 관련 항목**

**[한글 인코딩](%ED%95%9C%EA%B8%80%20%EC%9D%B8%EC%BD%94%EB%94%A9.md)**
[조합형](%EC%A1%B0%ED%95%A9%ED%98%95.md) ·
[완성형](%EC%99%84%EC%84%B1%ED%98%95.md) ([한글목록](%EC%99%84%EC%84%B1%ED%98%95/%ED%95%9C%EA%B8%80%20%EB%AA%A9%EB%A1%9D.md)
· [중복 한자](%EC%99%84%EC%84%B1%ED%98%95/%EC%A4%91%EB%B3%B5%20%ED%95%9C%EC%9E%90.md)) · [조합형 완성형 논쟁](%EC%A1%B0%ED%95%A9%ED%98%95%20%EC%99%84%EC%84%B1%ED%98%95%20%EB%85%BC%EC%9F%81.md) · [남북한 한글 코드의 충돌 문제](%EB%82%A8%EB%B6%81%ED%95%9C%20%ED%95%9C%EA%B8%80%20%EC%BD%94%EB%93%9C%EC%9D%98%20%EC%B6%A9%EB%8F%8C%20%EB%AC%B8%EC%A0%9C.md) · [한컴 2바이트 코드](%ED%95%9C%EC%BB%B4%202%EB%B0%94%EC%9D%B4%ED%8A%B8%20%EC%BD%94%EB%93%9C.md) ·
[유니코드](%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C.md)

**[타자기](%ED%83%80%EC%9E%90%EA%B8%B0.md)와 [키보드](%ED%82%A4%EB%B3%B4%EB%93%9C.md)**
[두벌식](%EB%91%90%EB%B2%8C%EC%8B%9D.md) ·
[세벌식](%EC%84%B8%EB%B2%8C%EC%8B%9D.md) · [휴대전화입력기](%ED%9C%B4%EB%8C%80%EC%A0%84%ED%99%94%20%EC%9E%85%EB%A0%A5%EA%B8%B0.md)
· [한영키](%ED%95%9C%EC%98%81%ED%82%A4.md)

**옛날에** 사용되던 [한글 인코딩](%ED%95%9C%EA%B8%80%20%EC%9D%B8%EC%BD%94%EB%94%A9.md) 방식 중 하나. 코드에는 자모만을 배당해 두고, 자모의 조합으로 한글을 표현한다. 과거형을 강조하는 이유는 지금은 옛한글을 표기할 때 이외에는 거의 사용하지 않는 방식이기 때문이다. 

표준이 아닌 것으로 많은 사람이 알고 있지만, 엄연한 표준 코드이다. KS X 1001의 부속서 3으로 수록되어 있기 때문.

조합형은 한글 글자를 만들 때 초성+중성+종성으로 조합해서 만든다. 가령 '만'이라는 글자를 입력하면 ㅁ+ㅏ+ㄴ 해서 '만'이 되는 식. 이
때 각 자모가 특정한 값을 가지고 이 값들을 나열하여 글자를 조합하기 때문에 조합형이라는 이름이 붙었다.

이렇게 하면 한글 자모음으로 결합해서 만드는 글자는 어떤 글자라도 전부 만들 수 있지만, 단점도 있다. 조합형이 여러 가지 종류가 있으니
각각 분리해서 설명하겠다.

  1. n바이트 조합형: 한글 낱자 하나 당 1바이트씩 할당하는 방식. 한글 창제원리를 완전히 반영한다면 한 글자에 들어가는 바이트 수가 들쭉날쭉이 된다. 가령 '무' 는 ㅁ + ㅜ로 최소 2바이트가 들어가지만 '뷁'은 ㅂ + ㅜ + ㅔ + ㄹ + ㄱ로 최대 5바이트까지 늘어난다. 또한 문장 앞뒤에 시작(SI)과 끝(SO)을 알리는 별도 코드가 들어갔다. 이래저래 용량을 많이 잡아먹는 코드라서 널리 퍼지지는 못했다.
  2. 3바이트 조합형: 초성 + 중성 + 종성 문자를 배당하고(받침이 없는 글자는 채움 글자를 따로 쓴다) 조합하는 3바이트 조합형을 고안하기도 했지만, 글자당 2바이트를 소비하는 완성형에 비해 효율이 낮다.
  3. 2바이트 조합형: 보통 조합형은 2바이트 조합형을 의미한다`[1]` 2바이트 16비트에서 앞 1비트는 한글임을 알리고, 나머지 15비트를 5비트씩 잘라 배당했다. 그런데 이 규격을 각 회사마다 독자적으로 정해버려서`[2]` 서로 호환이 되지 않았고, 2번째 바이트의 첫 비트가 0이면 다른 ASCII 코드와 충돌할 수 있다. 나중에 이것이 '''상용 조합형'(삼보 조합형, KSSM)''으로 정리되고, 1992년에 표준으로 지정된다(KS X 1001의 부속서 3으로 수록됨).  

[DOS](DOS.md) 시절에는 그래픽을 지원하는 프로그램 개발자들에게 있어 완성형보다 선호되었는데, 글꼴을 만들기가 용이하고
프로그램 사용에 있어서 훨씬 유연했기 때문이다. 키보드 입력값을 받아 합치기만 하면 글자가 완성되는 조합형이라 속도 차이도 많이 났다.

[조합형 완성형 논쟁](%EC%A1%B0%ED%95%A9%ED%98%95%20%EC%99%84%EC%84%B1%ED%98%95%20%EB%85%BC%EC%9F%81.md) 때, 조합형을 미는 사람들이 항상 주장했던 것이 현대 한글을 모두 표현할 수 있다는 것, 바로
**찦차를 타고 온 펲시맨과 쑛다리 똠방각하** 였다. 현대 한국인은 이 문장을 무리 없이 읽지만, (기본)완성형 폰트를 쓰는 시스템에서는
표시할 수도 읽을 수도 없으며, 실제로 타이핑하면 **찌ㅍ차를 타고 온 페ㅍ시맨과 쑈ㅅ다리 또ㅁ방각하**라고 나온다. 어떤 사람이 이런 것에
불만을 갖고 글을 쓰면서 **찦차를 타고 온 펲시맨과 쑛다리 똠방각하**를 집어넣었으나, 인코딩이 어찌되어 **뾼차를 타고 온 최시맨과
뉵다리 馱방각하**처럼 바뀌어버렸다. [참고](http://johotogoshinentai.tistory.com/5)

이 논쟁은 나중에 [마이크로소프트](%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8.md)에서 [Windows 95](Windows%2095.md)에 확장
[완성형](%EC%99%84%EC%84%B1%ED%98%95.md)을 도입하면서 조합형은 완전히 묻혀버리게 되었다. 조합형이 주장하던
**한글 완전 구현**이, 마소에서 어거지로 나머지 문자를 죄다 배당하는 방식으로 땜빵한 덕분.

조합형이 묻혀버리게 된 이유 중 또 다른 하나는 외국어. 한글의 최소 단위는 자모인 게 맞지만, 이게 발음을 가지려면 순서대로 자 + 모
혹은 자 + 모 + 자`[3]` 순서로 문자를 정확히 조합해야 한다. 이렇게 조합된 글자 중 11,172자만 현대 한국어를 표현하는 데
쓰이며, 잘못 조합된 문자는 말이 안 되거나 옛한글이다. 전 세계 어디에도 이런 방식의 문자는 없기 때문에`[4]` 외국어와 한국어를 하나의
문자셋에서 처리하기 위해서는 좋든 싫든 저 11,172자를 전부 줄 세울 수밖에 없었기 때문이다. 그나마도 너무 많다 보니 안 쓰일 것 같은
글자는 다 털어내고 2350자만 줄 세워 정리한 게 지금의 [완성형](%EC%99%84%EC%84%B1%ED%98%95.md) KS X
1001이다. 이후 조합형도 나중에 정리된 2바이트 상용 조합형이 KS X 1001의 부속서 3으로 들어가면서 한글 코드는 2개의 표준을
가지게 되었다.

이후 유니코드에는 한글이 완성형으로 들어가지만, 현대 한글 11,172자가 모두 들어가기 때문에 특정 한글이 안나오거나 하는 문제는 없다.
하지만 고작 몇십 개의 자모로 구성된 한글이 11,172자나 써버리는 건 [안습](%EC%95%88%EC%8A%B5.md)이다.
<del>이게 다 우리가 컴퓨터를 발명하지 못해서다.</del>

유니코드에서는 자모 조합으로 한글을 만들 수도 있지만(첫가끝) 데이터 길이가 3배로
[뻥튀기](%EB%BB%A5%ED%8A%80%EA%B8%B0.md)되는 문제가 존재하기 때문에`[5]` 현대 한글을 표현할 때는
이용되지 않고 사실상 옛한글을 표시할 때만 이용된다. 유니코드의 한글 자모 영역에는 초성, 중성, 종성이 옛한글까지 모두 포함되어 있기
때문이다. 단 첫가끝 코드가 매우 절찬리에 쓰이는 곳이 한 군데 있는데, 바로 [OS X](OS%20X.md)이다. 애플의
[HFS+](HFS.md) 파일 시스템은 한글 파일명을 디스크에 저장할 때 첫가끝 코드로 저장하는데 이 때문에 OS X에서 파일을
전송하면(혹은 압축하면) [윈도우](%EC%9C%88%EB%8F%84%EC%9A%B0.md)나
[리눅스](%EB%A6%AC%EB%88%85%EC%8A%A4.md)에서 한글 파일명이 뼈와 살이 분리되는 경험을 할 수 있다.`[6]`
몇몇 가상머신에서는 자동으로 첫가끝을 완성형으로 바꿔주는 경우도 있다.

[Windows NT](Windows%20NT.md)부터는 운영체제 내부에서 프로그램이 구동될 때 항상 유니코드로만 돌아가고(프로그램이
비유니코드로 만들어져 있으면 실시간으로 변환되며 작동한다), 유니코드의 코드 구성 자체가 초성-중성-종성의 배열 조합으로 이루어져 있는
특성상 프로그래밍을 할 때 조합형 코드를 자체적으로 구현해서 사용할 이득은 사라졌다.

윈도우용 프로그램에서 끝까지 조합형을 지킨 프로그램은 다름아닌 [아래아한글](%EC%95%84%EB%9E%98%EC%95%84%20%ED%95%9C%EA%B8%80.md)(정확히는 조합형을 개조해서
옛한글을 집어넣은 [한컴 2바이트 코드](%ED%95%9C%EC%BB%B4%202%EB%B0%94%EC%9D%B4%ED%8A%B8%20%EC%BD%94%EB%93%9C.md)를 사용했다). 그러나 아래아 한글도 2000년 워디안 버전으로 넘어가면서 유니코드로 바꿨다.

유저들이 북미 게임의 한글 패치를 만들 때 이 조합형의 방법을 사용하는 경우가 있다. 북미 게임의 경우 1바이트
[ASCII](ASCII.md) 코드만 지원하는 경우가 있는데, ASCII 코드의 확장 영역에다 한글 낱자를 집어넣은 일종의 커스텀
코드를 만들어 한글 낱자를 [직결식글꼴](%EC%A7%81%EA%B2%B0%EC%8B%9D%20%EA%B8%80%EA%BC%B4.md)의 방법대로 화면에 출력한다.
[폴아웃 3](%ED%8F%B4%EC%95%84%EC%9B%83%203.md)와
[오블리비언](%EC%98%A4%EB%B8%94%EB%A6%AC%EB%B9%84%EC%96%B8.md)이 대표적인 예.

`\----`

  * `[1]` n바이트와 같이 길이가 변하지도 않고, 완성형과 효율이 같기 때문에 경쟁력이 있다.
  * `[2]` 금성 조합형, 삼성 조합형, 그리고 삼보를 중심으로 한 상용 조합형 등.
  * `[3]` 일단 이중모음과 겹받침도 한 자모로 보자. 이걸 다 잘라 생각하는 게 n바이트식인데, 이건 더 어려워진다.
  * `[4]` 한자에도 회의자나 형성자 등 여러 글자를 합쳐서 새로운 글자를 만드는 시스템은 있긴 하지만, 얘네들은 말만 되면 아무 글자나 줏대 없이 막 합쳐대고, 또 그러다 보니까 쓰기 불편하다고 간체라는 걸 만들면서 규칙이 죄다 박살났다.
  * `[5]` 자모 하나하나가 유니코드 한 글자로 취급되기 때문이다.
  * `[6]` 이용신청서 → ㅇㅣㅇㅛㅇㅅㅣㄴㅊㅓㅇㅅㅓ

